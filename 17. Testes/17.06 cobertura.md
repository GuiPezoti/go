# Cobertura de CÃ³digo

Cobertura de cÃ³digo mede qual porcentagem do seu cÃ³digo Ã© executada durante os testes. Go possui ferramentas nativas de cobertura extremamente poderosas que mostram nÃ£o apenas o percentual geral, mas tambÃ©m quais linhas especÃ­ficas foram ou nÃ£o testadas. Use cobertura como guia, nÃ£o como meta absoluta: 80-90% Ã© geralmente excelente, enquanto 100% pode indicar over-testing.

A cobertura visual (HTML) Ã© especialmente Ãºtil: linhas verdes foram testadas, vermelhas nÃ£o foram, e cinzas nÃ£o sÃ£o executÃ¡veis. Isso revela rapidamente edge cases esquecidos, branches de erro nÃ£o testados, ou cÃ³digo morto. Lembre-se: alta cobertura nÃ£o garante qualidade - vocÃª pode ter 100% de cobertura com testes ruins. Cobertura mede quantidade, nÃ£o qualidade. Use-a para encontrar gaps, nÃ£o como objetivo final.

## Comandos BÃ¡sicos
```bash
# Cobertura bÃ¡sica (apenas percentual)
go test -cover

# Output:
# PASS
# coverage: 85.7% of statements
# ok      myapp    0.234s

# Gerar relatÃ³rio de cobertura
go test -coverprofile=coverage.out

# Ver cobertura por funÃ§Ã£o
go tool cover -func=coverage.out

# Output:
# myapp/http.go:10:    doRequest         85.7%
# myapp/http.go:25:    parseResponse     100.0%
# myapp/utils.go:5:    helper            0.0%
# total:               (statements)      78.5%

# Ver cobertura visual (HTML) - MELHOR OPÃ‡ÃƒO
go tool cover -html=coverage.out
# Abre navegador com cÃ³digo colorido:
# ğŸŸ¢ Verde = linha testada
# ğŸ”´ Vermelho = linha NÃƒO testada
# âšª Cinza = linha nÃ£o executÃ¡vel (declaraÃ§Ãµes, comentÃ¡rios)

# Cobertura de mÃºltiplos packages
go test -cover ./...

# Cobertura com modo especÃ­fico
go test -covermode=count -coverprofile=coverage.out
# count: conta quantas vezes cada statement executa
# set: apenas marca se executou ou nÃ£o (padrÃ£o)
# atomic: como count mas thread-safe

# Gerar relatÃ³rio e abrir HTML em uma linha
go test -coverprofile=coverage.out && go tool cover -html=coverage.out
```

## Exemplo de CÃ³digo e Cobertura
```go
package myapp

import (
    "errors"
    "strings"
)

// FunÃ§Ã£o com cobertura parcial
func ProcessData(data string) (string, error) {
    if data == "" {                    // â† testado (verde)
        return "", errors.New("empty")  // â† testado (verde)
    }
    
    if len(data) > 100 {               // â† NÃƒO testado (vermelho)
        return "", errors.New("too long") // â† NÃƒO testado (vermelho)
    }
    
    result := strings.ToUpper(data)    // â† testado (verde)
    return result, nil                 // â† testado (verde)
}

// Teste que cobre parcialmente
func TestProcessData(t *testing.T) {
    tests := []struct {
        name    string
        input   string
        want    string
        wantErr bool
    }{
        {
            name:    "sucesso",
            input:   "hello",
            want:    "HELLO",
            wantErr: false,
        },
        {
            name:    "string vazia",
            input:   "",
            want:    "",
            wantErr: true,
        },
        // FALTANDO: caso com string > 100 chars
        // Cobertura mostrarÃ¡ as linhas do "too long" em vermelho
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            got, err := ProcessData(tt.input)
            
            if (err != nil) != tt.wantErr {
                t.Errorf("erro = %v; wantErr %v", err, tt.wantErr)
                return
            }
            
            if got != tt.want {
                t.Errorf("got %q; want %q", got, tt.want)
            }
        })
    }
}

// Para atingir 100% de cobertura, adicione:
// {
//     name:    "string muito longa",
//     input:   strings.Repeat("a", 101),
//     want:    "",
//     wantErr: true,
// },
```

## Interpretando Cobertura
```go
// Exemplo: funÃ§Ã£o com mÃºltiplos branches
func ValidateAge(age int) error {
    if age < 0 {           // branch 1
        return errors.New("idade negativa")
    }
    if age < 18 {          // branch 2
        return errors.New("menor de idade")
    }
    if age > 120 {         // branch 3
        return errors.New("idade invÃ¡lida")
    }
    return nil             // branch 4 (sucesso)
}

// Cobertura por cenÃ¡rio:

// Teste 1: age = 25 (sucesso)
// Cobre: linha 2 (false), linha 5 (false), linha 8 (false), linha 11
// Cobertura: 50% (4 de 8 linhas)

// Teste 2: adiciona age = -1
// Cobre: linha 2 (true), linha 3
// Nova cobertura: 62.5% (5 de 8 linhas)

// Teste 3: adiciona age = 15
// Cobre: linha 5 (true), linha 6
// Nova cobertura: 75% (6 de 8 linhas)

// Teste 4: adiciona age = 150
// Cobre: linha 8 (true), linha 9
// Nova cobertura: 100% (8 de 8 linhas)
```

## NÃ­veis de Cobertura
```
90-100%: Excelente (mas cuidado com over-testing)
         - Todos os caminhos principais cobertos
         - Edge cases testados
         - Pode indicar testes demais se > 95%

70-89%:  Bom (maioria dos casos cobertos)
         - Caminhos principais testados
         - Alguns edge cases podem faltar
         - NÃ­vel saudÃ¡vel para maioria dos projetos

50-69%:  RazoÃ¡vel (considere adicionar mais testes)
         - Cobertura bÃ¡sica presente
         - Muitos edge cases nÃ£o testados
         - Acceptable para cÃ³digo novo/experimentaÃ§Ã£o

<50%:    Baixo (muitos caminhos nÃ£o testados)
         - Poucos testes
         - Alto risco de bugs
         - Priorize adicionar testes
```

## Exemplos PrÃ¡ticos

### Identificando CÃ³digo NÃ£o Testado
```go
func CalculateDiscount(price float64, customer string) float64 {
    discount := 0.0
    
    if price > 100 {              // â† testado
        discount = 0.1             // â† testado
    }
    
    if customer == "premium" {    // â† NÃƒO testado (vermelho)
        discount += 0.05           // â† NÃƒO testado (vermelho)
    }
    
    if customer == "vip" {        // â† NÃƒO testado (vermelho)
        discount += 0.15           // â† NÃƒO testado (vermelho)
    }
    
    return price * (1 - discount) // â† testado
}

// Testes atuais (cobertura parcial)
func TestCalculateDiscount(t *testing.T) {
    tests := []struct {
        price    float64
        customer string
        want     float64
    }{
        {50, "regular", 50},     // nÃ£o entra em nenhum if
        {150, "regular", 135},   // entra apenas no primeiro if
        // Faltam casos: "premium" e "vip"
    }
    // Cobertura: ~60% (6 de 10 linhas)
}

// Adicionar para 100% de cobertura:
// {150, "premium", 127.5},  // testa branch "premium"
// {150, "vip", 112.5},      // testa branch "vip"
```

### CÃ³digo com Switch (Coverage)
```go
func GetStatusMessage(code int) string {
    switch code {
    case 200:                    // â† testado
        return "OK"              // â† testado
    case 404:                    // â† NÃƒO testado (vermelho)
        return "Not Found"       // â† NÃƒO testado (vermelho)
    case 500:                    // â† NÃƒO testado (vermelho)
        return "Server Error"    // â† NÃƒO testado (vermelho)
    default:                     // â† NÃƒO testado (vermelho)
        return "Unknown"         // â† NÃƒO testado (vermelho)
    }
}

// Para 100%, teste todos os cases + default
func TestGetStatusMessage(t *testing.T) {
    tests := []struct {
        code int
        want string
    }{
        {200, "OK"},              // âœ…
        {404, "Not Found"},       // âœ…
        {500, "Server Error"},    // âœ…
        {999, "Unknown"},         // âœ… (default)
    }
    // Agora: 100% de cobertura
}
```

### Early Returns e Coverage
```go
func ProcessOrder(order *Order) error {
    if order == nil {                        // â† testado
        return errors.New("order is nil")    // â† testado
    }
    
    if order.Items == nil {                  // â† NÃƒO testado
        return errors.New("no items")        // â† NÃƒO testado
    }
    
    if order.Total <= 0 {                    // â† NÃƒO testado
        return errors.New("invalid total")   // â† NÃƒO testado
    }
    
    // process order                         // â† testado
    return nil                               // â† testado
}

// Teste atual
func TestProcessOrder(t *testing.T) {
    // Apenas testa caso nil
    err := ProcessOrder(nil)
    if err == nil {
        t.Error("deveria retornar erro")
    }
    
    // Caso de sucesso
    order := &Order{Items: []Item{{Name: "test"}}, Total: 100}
    err = ProcessOrder(order)
    if err != nil {
        t.Error("nÃ£o deveria retornar erro")
    }
}

// Cobertura: ~60% (falta testar Items == nil e Total <= 0)
```

## Cobertura em CI/CD
```bash
#!/bin/bash
# Script para CI/CD

# Roda testes com cobertura
go test -coverprofile=coverage.out ./...

# Extrai percentual de cobertura
COVERAGE=$(go tool cover -func=coverage.out | grep total | awk '{print $3}' | sed 's/%//')

echo "Cobertura: ${COVERAGE}%"

# Falha se cobertura < 80%
if (( $(echo "$COVERAGE < 80" | bc -l) )); then
    echo "âŒ Cobertura muito baixa! MÃ­nimo: 80%"
    exit 1
fi

echo "âœ… Cobertura adequada"
exit 0
```

## GitHub Actions Example
```yaml
name: Tests with Coverage

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: '1.21'
      
      - name: Run tests with coverage
        run: go test -v -coverprofile=coverage.out ./...
      
      - name: Check coverage
        run: |
          go tool cover -func=coverage.out
          COVERAGE=$(go tool cover -func=coverage.out | grep total | awk '{print $3}' | sed 's/%//')
          echo "Coverage: ${COVERAGE}%"
          if (( $(echo "$COVERAGE < 80" | bc -l) )); then
            echo "Coverage too low!"
            exit 1
          fi
      
      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v3
        with:
          file: ./coverage.out
```

## IMPORTANTE: Cobertura NÃ£o Ã‰ Tudo
```go
// âŒ 100% de cobertura com teste RUIM
func TestAdd_BadButFullCoverage(t *testing.T) {
    Add(2, 3)  // executado mas NÃƒO validado!
    Add(-1, 1) // executado mas NÃƒO validado!
    Add(0, 0)  // executado mas NÃƒO validado!
}
// Cobertura: 100% âœ…
// Qualidade: 0% âŒ (nÃ£o valida nada!)

// âœ… 80% de cobertura com teste BOM
func TestAdd_GoodButPartialCoverage(t *testing.T) {
    tests := []struct {
        a, b, want int
    }{
        {2, 3, 5},
        {-1, 1, 0},
        // nÃ£o testa todos os casos, mas VALIDA o que testa
    }
    
    for _, tt := range tests {
        got := Add(tt.a, tt.b)
        if got != tt.want {
            t.Errorf("Add(%d, %d) = %d; want %d", 
                tt.a, tt.b, got, tt.want)
        }
    }
}
// Cobertura: 80%
// Qualidade: Alta âœ… (valida corretamente)
```

## O Que NÃ£o Precisa de 100% de Cobertura
```go
// Getters/Setters simples (nÃ£o precisa testar)
func (u *User) Name() string {
    return u.name
}

func (u *User) SetName(name string) {
    u.name = name
}

// Construtores triviais (nÃ£o precisa testar)
func NewUser(name string) *User {
    return &User{name: name}
}

// CÃ³digo gerado automaticamente
//go:generate ...

// Main functions (testar em integraÃ§Ã£o)
func main() {
    // ...
}

// CÃ³digo impossÃ­vel de atingir
func impossible() {
    if false {  // nunca executarÃ¡
        panic("impossible")
    }
}
```

## Comandos AvanÃ§ados
```bash
# Cobertura de packages especÃ­ficos
go test -cover -coverpkg=./internal/... ./...

# MÃºltiplos arquivos de cobertura
go test -coverprofile=coverage1.out ./pkg1
go test -coverprofile=coverage2.out ./pkg2

# Merge coverage files (requer ferramenta externa)
gocovmerge coverage1.out coverage2.out > coverage.out

# Cobertura apenas de cÃ³digo modificado (com git)
go test -coverprofile=coverage.out ./...
git diff --name-only main | grep '\.go$' | xargs go tool cover -func=coverage.out
```

## Dicas PrÃ¡ticas
```
1. Use cobertura para ENCONTRAR gaps, nÃ£o como objetivo
2. 80-90% Ã© um bom alvo para maioria dos projetos
3. Foque em testar caminhos crÃ­ticos primeiro
4. Cobertura visual (HTML) Ã© sua melhor amiga
5. NÃ£o force 100% em cÃ³digo trivial
6. Alta cobertura â‰  bons testes
7. Adicione coverage check no CI/CD
8. Revise periodicamente cÃ³digo nÃ£o coberto
9. Use coverage para priorizar novos testes
10. Qualidade > Quantidade
```

## Checklist
```
âœ… Roda go test -cover regularmente
âœ… Visualiza HTML ao adicionar novos testes
âœ… Cobre caminhos de erro tanto quanto sucesso
âœ… Testa edge cases revelados pela cobertura
âœ… Tem meta de cobertura no CI/CD (80%+)
âœ… Valida o que testa (nÃ£o sÃ³ executa)
âœ… Foca em cÃ³digo crÃ­tico primeiro
âœ… Ignora cÃ³digo trivial (getters/setters)

âŒ NÃ£o forÃ§a 100% a qualquer custo
âŒ NÃ£o usa cobertura como Ãºnica mÃ©trica
âŒ NÃ£o testa apenas para subir percentual
âŒ NÃ£o ignora qualidade em favor de quantidade
```