# Equivalence Partitioning e Casos de Teste

Equivalence partitioning √© a t√©cnica de dividir inputs poss√≠veis em "classes de equival√™ncia" - grupos onde todos os valores devem se comportar da mesma forma. Ao inv√©s de testar todos os valores poss√≠veis (imposs√≠vel), voc√™ testa **representantes** de cada classe. Por exemplo, para testar uma fun√ß√£o que divide n√∫meros, voc√™ n√£o testa `Divide(10,2), Divide(20,4), Divide(30,6)...` - todos s√£o da mesma classe "divis√£o normal". Voc√™ testa um de cada classe: divis√£o normal, divis√£o por zero, resultado negativo, etc.

Essa t√©cnica evita testes redundantes enquanto mant√©m cobertura efetiva. Identifique as "parti√ß√µes" do seu dom√≠nio: sucesso/erro, positivo/negativo/zero, vazio/pequeno/grande, v√°lido/inv√°lido. Teste boundary values (valores limites) entre parti√ß√µes, pois bugs frequentemente aparecem nas fronteiras. Combine com table-driven tests para testar m√∫ltiplas parti√ß√µes de forma organizada. Esta √© uma das t√©cnicas mais importantes para criar su√≠tes de testes eficientes e abrangentes.

## Identificando Parti√ß√µes
```go
package validation

import (
    "errors"
    "testing"
)

// Fun√ß√£o que valida idade
func ValidateAge(age int) error {
    if age < 0 {
        return errors.New("idade negativa")
    }
    if age < 18 {
        return errors.New("menor de idade")
    }
    if age > 120 {
        return errors.New("idade inv√°lida")
    }
    return nil
}

// Identificando parti√ß√µes:
// 1. age < 0       (inv√°lido - negativo)
// 2. 0 <= age < 18 (inv√°lido - menor)
// 3. 18 <= age <= 120 (v√°lido)
// 4. age > 120     (inv√°lido - muito alto)

// Boundary values (valores limites):
// -1, 0, 17, 18, 120, 121

func TestValidateAge(t *testing.T) {
    tests := []struct {
        name    string
        age     int
        wantErr bool
        errMsg  string
    }{
        // Parti√ß√£o 1: negativos
        {
            name:    "negativo",
            age:     -1,  // representante da parti√ß√£o
            wantErr: true,
            errMsg:  "idade negativa",
        },
        {
            name:    "muito negativo",
            age:     -100,  // outro representante (opcional)
            wantErr: true,
            errMsg:  "idade negativa",
        },
        
        // Parti√ß√£o 2: menores de idade
        {
            name:    "zero (boundary)",
            age:     0,   // boundary value
            wantErr: true,
            errMsg:  "menor de idade",
        },
        {
            name:    "menor de idade",
            age:     10,  // representante da parti√ß√£o
            wantErr: true,
            errMsg:  "menor de idade",
        },
        {
            name:    "17 (boundary)",
            age:     17,  // boundary value
            wantErr: true,
            errMsg:  "menor de idade",
        },
        
        // Parti√ß√£o 3: v√°lidos
        {
            name:    "18 (boundary - v√°lido)",
            age:     18,  // boundary value
            wantErr: false,
        },
        {
            name:    "idade normal",
            age:     30,  // representante da parti√ß√£o
            wantErr: false,
        },
        {
            name:    "120 (boundary - m√°ximo v√°lido)",
            age:     120,  // boundary value
            wantErr: false,
        },
        
        // Parti√ß√£o 4: muito altos
        {
            name:    "121 (boundary - inv√°lido)",
            age:     121,  // boundary value
            wantErr: true,
            errMsg:  "idade inv√°lida",
        },
        {
            name:    "muito alto",
            age:     200,  // representante da parti√ß√£o
            wantErr: true,
            errMsg:  "idade inv√°lida",
        },
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            err := ValidateAge(tt.age)
            
            if (err != nil) != tt.wantErr {
                t.Errorf("ValidateAge(%d) erro = %v; wantErr %v", 
                    tt.age, err, tt.wantErr)
            }
            
            if tt.wantErr && tt.errMsg != "" {
                if !strings.Contains(err.Error(), tt.errMsg) {
                    t.Errorf("mensagem = %q; want %q", err.Error(), tt.errMsg)
                }
            }
        })
    }
}
```

## Exemplo: Testando Status Codes HTTP
```go
// N√ÉO teste TODOS os c√≥digos (200, 201, 202, 203...)
// Teste representantes de cada CATEGORIA

func ProcessHTTPResponse(statusCode int) error {
    if statusCode == 200 {
        return nil  // sucesso
    }
    return fmt.Errorf("status: %d", statusCode)
}

func TestProcessHTTPResponse(t *testing.T) {
    tests := []struct {
        name       string
        statusCode int
        wantErr    bool
    }{
        // Parti√ß√£o: 200 (√∫nico aceito)
        {
            name:       "200 OK",
            statusCode: 200,
            wantErr:    false,
        },
        
        // Parti√ß√£o: 2xx (outros - n√£o aceitos)
        {
            name:       "201 Created",
            statusCode: 201,
            wantErr:    true,
        },
        {
            name:       "204 No Content",
            statusCode: 204,
            wantErr:    true,
        },
        
        // Parti√ß√£o: 4xx (erro cliente)
        {
            name:       "400 Bad Request",
            statusCode: 400,
            wantErr:    true,
        },
        {
            name:       "404 Not Found",
            statusCode: 404,
            wantErr:    true,
        },
        
        // Parti√ß√£o: 5xx (erro servidor)
        {
            name:       "500 Internal Error",
            statusCode: 500,
            wantErr:    true,
        },
        {
            name:       "503 Unavailable",
            statusCode: 503,
            wantErr:    true,
        },
    }
    
    // N√£o precisa testar 401, 402, 403, 405... (mesma parti√ß√£o)
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            err := ProcessHTTPResponse(tt.statusCode)
            
            if (err != nil) != tt.wantErr {
                t.Errorf("erro = %v; wantErr %v", err, tt.wantErr)
            }
        })
    }
}
```

## Edge Cases Comuns por Tipo

### Strings
```go
func ProcessString(s string) (string, error) {
    if s == "" {
        return "", errors.New("empty")
    }
    if len(s) > 100 {
        return "", errors.New("too long")
    }
    return strings.ToUpper(s), nil
}

func TestProcessString(t *testing.T) {
    tests := []struct {
        name    string
        input   string
        want    string
        wantErr bool
    }{
        // Parti√ß√£o: vazia
        {
            name:    "string vazia",
            input:   "",
            wantErr: true,
        },
        
        // Parti√ß√£o: v√°lida (1 a 100 chars)
        {
            name:    "um caractere",
            input:   "a",
            want:    "A",
            wantErr: false,
        },
        {
            name:    "string normal",
            input:   "hello world",
            want:    "HELLO WORLD",
            wantErr: false,
        },
        {
            name:    "100 caracteres (boundary)",
            input:   strings.Repeat("a", 100),
            want:    strings.Repeat("A", 100),
            wantErr: false,
        },
        
        // Parti√ß√£o: muito longa (> 100)
        {
            name:    "101 caracteres (boundary)",
            input:   strings.Repeat("a", 101),
            wantErr: true,
        },
        {
            name:    "muito longa",
            input:   strings.Repeat("a", 200),
            wantErr: true,
        },
        
        // Edge cases especiais
        {
            name:    "caracteres especiais",
            input:   "hello\nworld\t!",
            want:    "HELLO\nWORLD\t!",
            wantErr: false,
        },
        {
            name:    "unicode/emojis",
            input:   "hello üòÄ",
            want:    "HELLO üòÄ",
            wantErr: false,
        },
        {
            name:    "espa√ßos",
            input:   "   ",
            want:    "   ",
            wantErr: false,
        },
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            got, err := ProcessString(tt.input)
            
            if (err != nil) != tt.wantErr {
                t.Errorf("erro = %v; wantErr %v", err, tt.wantErr)
                return
            }
            
            if !tt.wantErr && got != tt.want {
                t.Errorf("got %q; want %q", got, tt.want)
            }
        })
    }
}
```

### N√∫meros
```go
func CalculateDiscount(amount float64) float64 {
    if amount <= 0 {
        return 0
    }
    if amount < 100 {
        return amount * 0.05  // 5%
    }
    if amount < 1000 {
        return amount * 0.10  // 10%
    }
    return amount * 0.15  // 15%
}

func TestCalculateDiscount(t *testing.T) {
    tests := []struct {
        name   string
        amount float64
        want   float64
    }{
        // Parti√ß√£o: <= 0
        {
            name:   "zero",
            amount: 0,
            want:   0,
        },
        {
            name:   "negativo",
            amount: -10,
            want:   0,
        },
        
        // Parti√ß√£o: 0 < amount < 100 (5%)
        {
            name:   "0.01 (boundary)",
            amount: 0.01,
            want:   0.0005,
        },
        {
            name:   "50 (representante)",
            amount: 50,
            want:   2.5,
        },
        {
            name:   "99.99 (boundary)",
            amount: 99.99,
            want:   4.9995,
        },
        
        // Parti√ß√£o: 100 <= amount < 1000 (10%)
        {
            name:   "100 (boundary)",
            amount: 100,
            want:   10,
        },
        {
            name:   "500 (representante)",
            amount: 500,
            want:   50,
        },
        {
            name:   "999.99 (boundary)",
            amount: 999.99,
            want:   99.999,
        },
        
        // Parti√ß√£o: >= 1000 (15%)
        {
            name:   "1000 (boundary)",
            amount: 1000,
            want:   150,
        },
        {
            name:   "5000 (representante)",
            amount: 5000,
            want:   750,
        },
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            got := CalculateDiscount(tt.amount)
            
            // Compara√ß√£o com float precisa de toler√¢ncia
            if math.Abs(got-tt.want) > 0.0001 {
                t.Errorf("got %f; want %f", got, tt.want)
            }
        })
    }
}
```

### Slices/Arrays
```go
func Sum(numbers []int) int {
    total := 0
    for _, n := range numbers {
        total += n
    }
    return total
}

func TestSum(t *testing.T) {
    tests := []struct {
        name     string
        numbers  []int
        expected int
    }{
        // Parti√ß√£o: nil
        {
            name:     "nil slice",
            numbers:  nil,
            expected: 0,
        },
        
        // Parti√ß√£o: vazio
        {
            name:     "slice vazio",
            numbers:  []int{},
            expected: 0,
        },
        
        // Parti√ß√£o: um elemento
        {
            name:     "um elemento positivo",
            numbers:  []int{5},
            expected: 5,
        },
        {
            name:     "um elemento negativo",
            numbers:  []int{-5},
            expected: -5,
        },
        {
            name:     "um elemento zero",
            numbers:  []int{0},
            expected: 0,
        },
        
        // Parti√ß√£o: m√∫ltiplos elementos
        {
            name:     "todos positivos",
            numbers:  []int{1, 2, 3, 4, 5},
            expected: 15,
        },
        {
            name:     "todos negativos",
            numbers:  []int{-1, -2, -3},
            expected: -6,
        },
        {
            name:     "misturado",
            numbers:  []int{10, -5, 3, -2},
            expected: 6,
        },
        {
            name:     "com zeros",
            numbers:  []int{0, 5, 0, 3, 0},
            expected: 8,
        },
        
        // Edge case: slice grande
        {
            name:     "muitos elementos",
            numbers:  make([]int, 1000), // slice com 1000 zeros
            expected: 0,
        },
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            result := Sum(tt.numbers)
            
            if result != tt.expected {
                t.Errorf("Sum(%v) = %d; want %d", 
                    tt.numbers, result, tt.expected)
            }
        })
    }
}
```

### Maps
```go
func GetValue(m map[string]int, key string) (int, bool) {
    val, ok := m[key]
    return val, ok
}

func TestGetValue(t *testing.T) {
    tests := []struct {
        name      string
        m         map[string]int
        key       string
        wantValue int
        wantOk    bool
    }{
        // Parti√ß√£o: map nil
        {
            name:      "map nil",
            m:         nil,
            key:       "any",
            wantValue: 0,
            wantOk:    false,
        },
        
        // Parti√ß√£o: map vazio
        {
            name:      "map vazio",
            m:         map[string]int{},
            key:       "any",
            wantValue: 0,
            wantOk:    false,
        },
        
        // Parti√ß√£o: chave existe
        {
            name:      "chave existe",
            m:         map[string]int{"key": 42},
            key:       "key",
            wantValue: 42,
            wantOk:    true,
        },
        {
            name:      "valor zero mas existe",
            m:         map[string]int{"key": 0},
            key:       "key",
            wantValue: 0,
            wantOk:    true,
        },
        
        // Parti√ß√£o: chave n√£o existe
        {
            name:      "chave n√£o existe",
            m:         map[string]int{"other": 42},
            key:       "key",
            wantValue: 0,
            wantOk:    false,
        },
        
        // Edge cases
        {
            name:      "chave vazia",
            m:         map[string]int{"": 42},
            key:       "",
            wantValue: 42,
            wantOk:    true,
        },
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            gotValue, gotOk := GetValue(tt.m, tt.key)
            
            if gotOk != tt.wantOk {
                t.Errorf("ok = %v; want %v", gotOk, tt.wantOk)
            }
            
            if gotValue != tt.wantValue {
                t.Errorf("value = %d; want %d", gotValue, tt.wantValue)
            }
        })
    }
}
```

## Exemplo Completo: Fun√ß√£o de Busca
```go
func Search(items []string, target string) (int, bool) {
    for i, item := range items {
        if item == target {
            return i, true
        }
    }
    return -1, false
}

func TestSearch(t *testing.T) {
    tests := []struct {
        name      string
        items     []string
        target    string
        wantIndex int
        wantFound bool
    }{
        // Parti√ß√£o: slice nil/vazio
        {
            name:      "slice nil",
            items:     nil,
            target:    "x",
            wantIndex: -1,
            wantFound: false,
        },
        {
            name:      "slice vazio",
            items:     []string{},
            target:    "x",
            wantIndex: -1,
            wantFound: false,
        },
        
        // Parti√ß√£o: elemento encontrado (posi√ß√µes diferentes)
        {
            name:      "primeiro elemento",
            items:     []string{"a", "b", "c"},
            target:    "a",
            wantIndex: 0,
            wantFound: true,
        },
        {
            name:      "meio",
            items:     []string{"a", "b", "c"},
            target:    "b",
            wantIndex: 1,
            wantFound: true,
        },
        {
            name:      "√∫ltimo elemento",
            items:     []string{"a", "b", "c"},
            target:    "c",
            wantIndex: 2,
            wantFound: true,
        },
        
        // Parti√ß√£o: n√£o encontrado
        {
            name:      "n√£o existe",
            items:     []string{"a", "b", "c"},
            target:    "x",
            wantIndex: -1,
            wantFound: false,
        },
        
        // Edge cases
        {
            name:      "target vazio existe",
            items:     []string{"a", "", "c"},
            target:    "",
            wantIndex: 1,
            wantFound: true,
        },
        {
            name:      "target vazio n√£o existe",
            items:     []string{"a", "b", "c"},
            target:    "",
            wantIndex: -1,
            wantFound: false,
        },
        {
            name:      "duplicatas (retorna primeiro)",
            items:     []string{"a", "b", "a"},
            target:    "a",
            wantIndex: 0,
            wantFound: true,
        },
        {
            name:      "case sensitive",
            items:     []string{"Hello"},
            target:    "hello",
            wantIndex: -1,
            wantFound: false,
        },
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            gotIndex, gotFound := Search(tt.items, tt.target)
            
            if gotFound != tt.wantFound {
                t.Errorf("found = %v; want %v", gotFound, tt.wantFound)
            }
            
            if gotIndex != tt.wantIndex {
                t.Errorf("index = %d; want %d", gotIndex, tt.wantIndex)
            }
        })
    }
}
```

## Princ√≠pios de Equivalence Partitioning
```
1. Identifique parti√ß√µes (classes de comportamento)
   - Sucesso vs erro
   - Vazio, pequeno, normal, grande
   - V√°lido vs inv√°lido
   - Positivo, zero, negativo

2. Teste um representante de cada parti√ß√£o
   - N√£o precisa testar todos os valores
   - Um ou dois por parti√ß√£o √© suficiente

3. Teste boundary values entre parti√ß√µes
   - Valores nos limites s√£o onde bugs aparecem
   - Ex: 0, -1, max, max+1

4. Foque em parti√ß√µes de erro tanto quanto sucesso
   - Testes de erro s√£o t√£o importantes
   - Validam robustez do c√≥digo

5. Use table-driven tests para organizar
   - F√°cil ver todas as parti√ß√µes
   - F√°cil adicionar novos casos

‚ùå N√£o teste valores redundantes da mesma parti√ß√£o
‚ùå N√£o force 100% de cobertura em c√≥digo trivial
‚ùå N√£o ignore edge cases e boundaries
```

## Checklist de Parti√ß√µes Comuns
```
Para qualquer fun√ß√£o, considere:

Inputs:
‚ñ° nil/null
‚ñ° vazio (string "", slice [], map {})
‚ñ° um elemento
‚ñ° m√∫ltiplos elementos
‚ñ° zero
‚ñ° positivo/negativo
‚ñ° boundary values (min, max, min-1, max+1)

Outputs:
‚ñ° sucesso
‚ñ° erro esperado
‚ñ° erro inesperado

Comportamento:
‚ñ° primeiro/√∫ltimo elemento
‚ñ° elemento do meio
‚ñ° elemento n√£o encontrado
‚ñ° duplicatas
‚ñ° case sensitivity
‚ñ° caracteres especiais
‚ñ° unicode/emojis
```