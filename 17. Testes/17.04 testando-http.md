# Testando Funções HTTP

Testar código HTTP em Go é surpreendentemente simples graças ao package `net/http/httptest`, que fornece servidores e gravadores (recorders) para testes. Você pode criar servidores HTTP completos que rodam localmente apenas durante os testes, simulando APIs reais sem fazer chamadas de rede. Isso torna os testes rápidos, determinísticos e independentes de serviços externos.

A estratégia mais comum é usar `httptest.NewServer()` para criar um servidor mock que responde exatamente como você configurar. Sua função sendo testada faz requisições HTTP normais para esse servidor, sem saber que está sendo testada. Isso testa o fluxo completo: construção de requests, execução de chamadas HTTP, parsing de responses e tratamento de erros. O servidor mock roda em uma porta local aleatória, garante isolamento total, e é automaticamente fechado ao final do teste.
```go
package api

import (
    "context"
    "fmt"
    "io"
    "net/http"
    "net/http/httptest"
    "strings"
    "testing"
)

// Função que queremos testar
func FetchData(ctx context.Context, client *http.Client, url string) ([]byte, error) {
    req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
    if err != nil {
        return nil, err
    }
    
    resp, err := client.Do(req)
    if err != nil {
        return nil, err
    }
    defer resp.Body.Close()
    
    if resp.StatusCode != http.StatusOK {
        return nil, fmt.Errorf("status: %d", resp.StatusCode)
    }
    
    return io.ReadAll(resp.Body)
}

// Teste básico com httptest
func TestFetchData(t *testing.T) {
    // Cria servidor mock
    server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        // Servidor responde com dados fixos
        w.WriteHeader(http.StatusOK)
        w.Write([]byte("test data"))
    }))
    defer server.Close()  // Garante que servidor fecha
    
    // Testa a função apontando para o mock
    data, err := FetchData(context.Background(), server.Client(), server.URL)
    
    if err != nil {
        t.Fatalf("erro inesperado: %v", err)
    }
    
    expected := "test data"
    if string(data) != expected {
        t.Errorf("got %q; want %q", data, expected)
    }
}

// Table-driven test para HTTP
func TestFetchDataCases(t *testing.T) {
    tests := []struct {
        name           string
        serverResponse string
        serverStatus   int
        wantErr        bool
        expectedData   string
    }{
        {
            name:           "sucesso",
            serverResponse: "success",
            serverStatus:   http.StatusOK,
            wantErr:        false,
            expectedData:   "success",
        },
        {
            name:           "not found",
            serverResponse: "not found",
            serverStatus:   http.StatusNotFound,
            wantErr:        true,
            expectedData:   "",
        },
        {
            name:           "server error",
            serverResponse: "error",
            serverStatus:   http.StatusInternalServerError,
            wantErr:        true,
            expectedData:   "",
        },
        {
            name:           "body vazio",
            serverResponse: "",
            serverStatus:   http.StatusOK,
            wantErr:        false,
            expectedData:   "",
        },
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            // Cada subtest tem seu próprio servidor
            server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
                w.WriteHeader(tt.serverStatus)
                w.Write([]byte(tt.serverResponse))
            }))
            defer server.Close()
            
            data, err := FetchData(context.Background(), server.Client(), server.URL)
            
            // Valida erro
            if (err != nil) != tt.wantErr {
                t.Errorf("erro = %v; wantErr %v", err, tt.wantErr)
                return
            }
            
            // Valida dados se não esperava erro
            if !tt.wantErr && string(data) != tt.expectedData {
                t.Errorf("data = %q; want %q", data, tt.expectedData)
            }
        })
    }
}

// Validando detalhes do request
func TestFetchDataValidatesRequest(t *testing.T) {
    server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        // Valida método HTTP
        if r.Method != "GET" {
            t.Errorf("método = %s; want GET", r.Method)
        }
        
        // Valida path
        if r.URL.Path != "/" {
            t.Errorf("path = %s; want /", r.URL.Path)
        }
        
        // Valida headers se necessário
        if userAgent := r.Header.Get("User-Agent"); userAgent == "" {
            t.Error("User-Agent vazio")
        }
        
        w.WriteHeader(http.StatusOK)
        w.Write([]byte("ok"))
    }))
    defer server.Close()
    
    _, err := FetchData(context.Background(), server.Client(), server.URL)
    if err != nil {
        t.Fatalf("erro inesperado: %v", err)
    }
}

// Testando POST com body
func PostData(ctx context.Context, client *http.Client, url string, data string) error {
    body := strings.NewReader(data)
    req, err := http.NewRequestWithContext(ctx, "POST", url, body)
    if err != nil {
        return err
    }
    req.Header.Set("Content-Type", "application/json")
    
    resp, err := client.Do(req)
    if err != nil {
        return err
    }
    defer resp.Body.Close()
    
    if resp.StatusCode != http.StatusOK {
        return fmt.Errorf("status: %d", resp.StatusCode)
    }
    
    return nil
}

func TestPostData(t *testing.T) {
    expectedBody := `{"key":"value"}`
    
    server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        // Valida método
        if r.Method != "POST" {
            t.Errorf("método = %s; want POST", r.Method)
        }
        
        // Valida Content-Type
        ct := r.Header.Get("Content-Type")
        if ct != "application/json" {
            t.Errorf("Content-Type = %s; want application/json", ct)
        }
        
        // Valida body
        body, _ := io.ReadAll(r.Body)
        if string(body) != expectedBody {
            t.Errorf("body = %s; want %s", body, expectedBody)
        }
        
        w.WriteHeader(http.StatusOK)
    }))
    defer server.Close()
    
    err := PostData(context.Background(), server.Client(), server.URL, expectedBody)
    if err != nil {
        t.Fatalf("erro inesperado: %v", err)
    }
}

// Testando query parameters
func FetchUserByID(ctx context.Context, client *http.Client, baseURL string, userID int) (*User, error) {
    url := fmt.Sprintf("%s/users?id=%d", baseURL, userID)
    
    req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
    if err != nil {
        return nil, err
    }
    
    resp, err := client.Do(req)
    if err != nil {
        return nil, err
    }
    defer resp.Body.Close()
    
    if resp.StatusCode != http.StatusOK {
        return nil, fmt.Errorf("status: %d", resp.StatusCode)
    }
    
    var user User
    if err := json.NewDecoder(resp.Body).Decode(&user); err != nil {
        return nil, err
    }
    
    return &user, nil
}

func TestFetchUserByID(t *testing.T) {
    tests := []struct {
        name       string
        userID     int
        mockStatus int
        mockUser   User
        wantErr    bool
    }{
        {
            name:       "usuário existe",
            userID:     123,
            mockStatus: http.StatusOK,
            mockUser:   User{ID: 123, Name: "John"},
            wantErr:    false,
        },
        {
            name:       "usuário não encontrado",
            userID:     999,
            mockStatus: http.StatusNotFound,
            wantErr:    true,
        },
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
                // Valida query parameter
                idStr := r.URL.Query().Get("id")
                if idStr != fmt.Sprintf("%d", tt.userID) {
                    t.Errorf("id = %s; want %d", idStr, tt.userID)
                }
                
                w.WriteHeader(tt.mockStatus)
                if tt.mockStatus == http.StatusOK {
                    json.NewEncoder(w).Encode(tt.mockUser)
                }
            }))
            defer server.Close()
            
            user, err := FetchUserByID(context.Background(), server.Client(), server.URL, tt.userID)
            
            if (err != nil) != tt.wantErr {
                t.Errorf("erro = %v; wantErr %v", err, tt.wantErr)
                return
            }
            
            if !tt.wantErr {
                if user.ID != tt.mockUser.ID {
                    t.Errorf("ID = %d; want %d", user.ID, tt.mockUser.ID)
                }
                if user.Name != tt.mockUser.Name {
                    t.Errorf("Name = %s; want %s", user.Name, tt.mockUser.Name)
                }
            }
        })
    }
}

// Testando timeout com context
func TestFetchDataTimeout(t *testing.T) {
    // Servidor que demora para responder
    server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        time.Sleep(2 * time.Second)
        w.Write([]byte("ok"))
    }))
    defer server.Close()
    
    // Context com timeout de 100ms
    ctx, cancel := context.WithTimeout(context.Background(), 100*time.Millisecond)
    defer cancel()
    
    _, err := FetchData(ctx, server.Client(), server.URL)
    
    if err == nil {
        t.Error("deveria ter dado timeout")
    }
    
    if !strings.Contains(err.Error(), "context deadline exceeded") {
        t.Errorf("erro = %v; deveria conter 'context deadline exceeded'", err)
    }
}

// Testando headers customizados
func FetchWithAuth(ctx context.Context, client *http.Client, url, token string) ([]byte, error) {
    req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
    if err != nil {
        return nil, err
    }
    
    req.Header.Set("Authorization", "Bearer "+token)
    
    resp, err := client.Do(req)
    if err != nil {
        return nil, err
    }
    defer resp.Body.Close()
    
    if resp.StatusCode == http.StatusUnauthorized {
        return nil, fmt.Errorf("unauthorized")
    }
    
    if resp.StatusCode != http.StatusOK {
        return nil, fmt.Errorf("status: %d", resp.StatusCode)
    }
    
    return io.ReadAll(resp.Body)
}

func TestFetchWithAuth(t *testing.T) {
    tests := []struct {
        name       string
        token      string
        mockStatus int
        wantErr    bool
        errMsg     string
    }{
        {
            name:       "token válido",
            token:      "valid-token",
            mockStatus: http.StatusOK,
            wantErr:    false,
        },
        {
            name:       "token inválido",
            token:      "invalid-token",
            mockStatus: http.StatusUnauthorized,
            wantErr:    true,
            errMsg:     "unauthorized",
        },
        {
            name:       "sem token",
            token:      "",
            mockStatus: http.StatusUnauthorized,
            wantErr:    true,
            errMsg:     "unauthorized",
        },
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
                // Valida header Authorization
                auth := r.Header.Get("Authorization")
                expectedAuth := "Bearer " + tt.token
                
                if auth != expectedAuth {
                    t.Errorf("Authorization = %q; want %q", auth, expectedAuth)
                }
                
                w.WriteHeader(tt.mockStatus)
                if tt.mockStatus == http.StatusOK {
                    w.Write([]byte("secret data"))
                }
            }))
            defer server.Close()
            
            _, err := FetchWithAuth(context.Background(), server.Client(), server.URL, tt.token)
            
            if (err != nil) != tt.wantErr {
                t.Errorf("erro = %v; wantErr %v", err, tt.wantErr)
                return
            }
            
            if tt.wantErr && !strings.Contains(err.Error(), tt.errMsg) {
                t.Errorf("erro = %q; deveria conter %q", err.Error(), tt.errMsg)
            }
        })
    }
}

// Helper para criar servidor de teste (recomendado)
func newTestServer(t *testing.T, handler http.HandlerFunc) (*httptest.Server, *http.Client) {
    t.Helper()
    
    server := httptest.NewServer(handler)
    return server, server.Client()
}

// Usando o helper
func TestWithHelper(t *testing.T) {
    server, client := newTestServer(t, func(w http.ResponseWriter, r *http.Request) {
        w.WriteHeader(http.StatusOK)
        w.Write([]byte("ok"))
    })
    defer server.Close()
    
    data, err := FetchData(context.Background(), client, server.URL)
    
    if err != nil {
        t.Fatalf("erro: %v", err)
    }
    
    if string(data) != "ok" {
        t.Errorf("data = %q; want ok", data)
    }
}

// Testando múltiplas chamadas
func TestMultipleCalls(t *testing.T) {
    callCount := 0
    
    server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        callCount++
        w.WriteHeader(http.StatusOK)
        fmt.Fprintf(w, "call %d", callCount)
    }))
    defer server.Close()
    
    // Primeira chamada
    data1, err := FetchData(context.Background(), server.Client(), server.URL)
    if err != nil {
        t.Fatalf("call 1 falhou: %v", err)
    }
    if string(data1) != "call 1" {
        t.Errorf("call 1 = %q; want 'call 1'", data1)
    }
    
    // Segunda chamada
    data2, err := FetchData(context.Background(), server.Client(), server.URL)
    if err != nil {
        t.Fatalf("call 2 falhou: %v", err)
    }
    if string(data2) != "call 2" {
        t.Errorf("call 2 = %q; want 'call 2'", data2)
    }
    
    // Verifica que foram 2 chamadas
    if callCount != 2 {
        t.Errorf("callCount = %d; want 2", callCount)
    }
}

// Testando diferentes paths
func TestDifferentPaths(t *testing.T) {
    server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        switch r.URL.Path {
        case "/users":
            w.Write([]byte("users"))
        case "/posts":
            w.Write([]byte("posts"))
        default:
            w.WriteHeader(http.StatusNotFound)
        }
    }))
    defer server.Close()
    
    tests := []struct {
        path string
        want string
    }{
        {"/users", "users"},
        {"/posts", "posts"},
    }
    
    for _, tt := range tests {
        t.Run(tt.path, func(t *testing.T) {
            url := server.URL + tt.path
            data, err := FetchData(context.Background(), server.Client(), url)
            
            if err != nil {
                t.Fatalf("erro: %v", err)
            }
            
            if string(data) != tt.want {
                t.Errorf("data = %q; want %q", data, tt.want)
            }
        })
    }
}

// Testando response headers
func TestResponseHeaders(t *testing.T) {
    server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        w.Header().Set("X-Custom-Header", "test-value")
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusOK)
        w.Write([]byte(`{"status":"ok"}`))
    }))
    defer server.Close()
    
    req, _ := http.NewRequest("GET", server.URL, nil)
    resp, err := server.Client().Do(req)
    if err != nil {
        t.Fatalf("erro: %v", err)
    }
    defer resp.Body.Close()
    
    // Valida headers da resposta
    if custom := resp.Header.Get("X-Custom-Header"); custom != "test-value" {
        t.Errorf("X-Custom-Header = %q; want 'test-value'", custom)
    }
    
    if ct := resp.Header.Get("Content-Type"); ct != "application/json" {
        t.Errorf("Content-Type = %q; want 'application/json'", ct)
    }
}
```

## Regras Importantes

### ✅ SEMPRE faça:

- Crie servidor dentro do `t.Run` (isolamento)
- Use `defer server.Close()`
- Use `server.URL` (não hardcode URLs)
- Use `server.Client()` (pré-configurado)
- Valide método, headers, body no handler
- Teste casos de sucesso E erro

### ❌ NUNCA faça:

- Requisições para APIs reais em testes
- Reutilize servidor entre subtests
- Hardcode portas ou URLs
- Esqueça de fechar o servidor
- Ignore erros de setup
- Compartilhe estado entre testes

## Comandos Úteis
```bash
# Rodar testes HTTP
go test -v

# Rodar com timeout
go test -timeout 30s

# Detectar race conditions
go test -race

# Ver cobertura
go test -cover
```

## Dicas Práticas
```go
// 1. Use helper para reduzir duplicação
func newTestServer(t *testing.T, handler http.HandlerFunc) (*httptest.Server, *http.Client) {
    t.Helper()
    server := httptest.NewServer(handler)
    return server, server.Client()
}

// 2. Valide requisições no handler
func(w http.ResponseWriter, r *http.Request) {
    if r.Method != "GET" {
        t.Errorf("método incorreto")
    }
    // ... validações
}

// 3. Use context para timeouts
ctx, cancel := context.WithTimeout(context.Background(), 1*time.Second)
defer cancel()

// 4. Teste múltiplos status codes
tests := []struct {
    status int
    wantErr bool
}{
    {200, false},
    {404, true},
    {500, true},
}
```