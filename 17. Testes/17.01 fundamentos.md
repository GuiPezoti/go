# Fundamentos de Testes em Go

Testes em Go são cidadãos de primeira classe da linguagem, integrados nativamente através do comando `go test` e do package `testing`. Diferente de outras linguagens que dependem de frameworks externos, Go fornece todas as ferramentas essenciais para testes na biblioteca padrão. Testes são escritos em arquivos terminados em `_test.go` e funções de teste devem começar com `Test` seguido de letra maiúscula.

A filosofia de testes em Go enfatiza simplicidade, clareza e explicitação. Não há magic ou DSLs complexas - apenas funções Go normais que recebem `*testing.T` e reportam falhas através de métodos simples como `t.Error()` e `t.Fatal()`. Essa abordagem torna testes fáceis de ler, escrever e depurar, mesmo para desenvolvedores que não conhecem frameworks de teste complexos. A convenção de co-localizar testes com código (mesmo diretório) e a execução paralela por padrão tornam o desenvolvimento mais ágil.
```go
// arquivo: calc.go
package calc

import "errors"

func Add(a, b int) int {
    return a + b
}

func Divide(a, b int) (int, error) {
    if b == 0 {
        return 0, errors.New("divisão por zero")
    }
    return a / b, nil
}

// arquivo: calc_test.go
package calc

import "testing"

// Teste básico - função deve começar com Test
func TestAdd(t *testing.T) {
    result := Add(2, 3)
    expected := 5
    
    if result != expected {
        t.Errorf("Add(2, 3) = %d; want %d", result, expected)
    }
}

// Teste com erro esperado
func TestDivideByZero(t *testing.T) {
    _, err := Divide(10, 0)
    
    if err == nil {
        t.Error("Divide(10, 0) deveria retornar erro")
    }
}

// Teste de sucesso
func TestDivideSuccess(t *testing.T) {
    result, err := Divide(10, 2)
    
    if err != nil {
        t.Fatalf("Divide(10, 2) retornou erro inesperado: %v", err)
    }
    
    if result != 5 {
        t.Errorf("Divide(10, 2) = %d; want 5", result)
    }
}

// Diferença entre t.Error() e t.Fatal()
func TestErrorVsFatal(t *testing.T) {
    // t.Error() - registra erro mas CONTINUA o teste
    if 1+1 == 3 {
        t.Error("matemática quebrou")
        // código aqui ainda executa
    }
    
    // t.Errorf() - Error com formatação
    x := 10
    if x != 10 {
        t.Errorf("x = %d; want 10", x)
    }
    
    // t.Fatal() - registra erro e PARA o teste imediatamente
    db, err := setupDatabase()
    if err != nil {
        t.Fatal("setup falhou:", err)  // para aqui
        // código abaixo NÃO executa
    }
    
    // t.Fatalf() - Fatal com formatação
    if db == nil {
        t.Fatalf("database é nil, não pode continuar")
    }
}

// Múltiplos testes no mesmo arquivo
func TestAddNegative(t *testing.T) {
    result := Add(-5, 3)
    if result != -2 {
        t.Errorf("Add(-5, 3) = %d; want -2", result)
    }
}

func TestAddZero(t *testing.T) {
    result := Add(0, 0)
    if result != 0 {
        t.Errorf("Add(0, 0) = %d; want 0", result)
    }
}

// t.Log() e t.Logf() - output apenas se teste falhar ou -v
func TestWithLogging(t *testing.T) {
    t.Log("Iniciando teste complexo")
    
    result := Add(2, 3)
    t.Logf("Resultado intermediário: %d", result)
    
    if result != 5 {
        t.Error("falhou")
    }
    // Logs só aparecem se teste falhar ou usar go test -v
}

// t.Skip() - pula teste condicionalmente
func TestCondicional(t *testing.T) {
    if testing.Short() {
        t.Skip("pulando teste longo em modo -short")
    }
    
    // teste demorado aqui
    time.Sleep(5 * time.Second)
}

// t.Helper() - marca função como helper (veremos mais adiante)
func assertEqual(t *testing.T, got, want int) {
    t.Helper()  // erros apontam para quem chamou, não para aqui
    
    if got != want {
        t.Errorf("got %d; want %d", got, want)
    }
}

func TestWithHelper(t *testing.T) {
    result := Add(2, 3)
    assertEqual(t, result, 5)  // erro aponta para esta linha
}

// Testando múltiplos cenários
func TestDivideVariousCases(t *testing.T) {
    // Divisão normal
    result, err := Divide(10, 2)
    if err != nil {
        t.Error("erro inesperado:", err)
    }
    if result != 5 {
        t.Error("resultado incorreto")
    }
    
    // Divisão por zero
    _, err = Divide(10, 0)
    if err == nil {
        t.Error("deveria retornar erro")
    }
    
    // Divisão com negativos
    result, err = Divide(-10, 2)
    if err != nil {
        t.Error("erro inesperado:", err)
    }
    if result != -5 {
        t.Error("resultado incorreto para negativos")
    }
}

// Testando panics
func Sqrt(n float64) float64 {
    if n < 0 {
        panic("raiz quadrada de número negativo")
    }
    return math.Sqrt(n)
}

func TestSqrtPanic(t *testing.T) {
    defer func() {
        if r := recover(); r == nil {
            t.Error("Sqrt(-1) deveria dar panic")
        }
    }()
    
    Sqrt(-1)  // vai dar panic
}

// Convenções de nomenclatura
// ✅ TestFunctionName - testa função específica
// ✅ TestFunctionName_Scenario - testa cenário específico
// ✅ TestStructName_MethodName - testa método de struct
// ❌ Test_functionName - underscore antes do nome (não é padrão)
// ❌ testFunctionName - não começa com maiúscula
// ❌ TestFunc - muito genérico

// Estrutura de um teste (padrão AAA)
func TestAAA(t *testing.T) {
    // ARRANGE - preparar dados/estado
    input := 10
    expected := 20
    
    // ACT - executar a ação
    result := Multiply(input, 2)
    
    // ASSERT - validar resultado
    if result != expected {
        t.Errorf("got %d; want %d", result, expected)
    }
}

// Package declaration - teste no mesmo package (acessa código privado)
package calc

// Ou teste em package externo (testa apenas API pública)
package calc_test

import (
    "testing"
    "myapp/calc"  // precisa importar
)
```

## Comandos Úteis
```bash
# Executar testes
go test                    # roda todos os testes do package atual
go test -v                 # modo verboso (mostra cada teste)
go test -run TestAdd       # roda apenas testes que correspondem ao regex
go test -run TestAdd/positive  # roda subteste específico
go test ./...              # roda testes de todos os subpackages

# Opções adicionais
go test -short             # roda apenas testes rápidos (que respeitam testing.Short())
go test -count=1           # desabilita cache (força re-execução)
go test -timeout 30s       # define timeout global
go test -parallel 4        # número de testes paralelos (padrão: GOMAXPROCS)
go test -race              # detecta race conditions
go test -coverprofile=coverage.out  # gera relatório de cobertura
```

## Regras Importantes

### ✅ Boas Práticas

- Arquivo de teste no mesmo diretório do código
- Nome do arquivo: `codigo.go` → `codigo_test.go`
- Função de teste: `func TestXxx(*testing.T)`
- Use `t.Error()` para múltiplas validações
- Use `t.Fatal()` quando erro impede continuação
- Testes devem ser independentes (sem ordem)
- Testes devem ser rápidos (< 1s idealmente)
- Nomes descritivos documentam o comportamento

### ❌ Evite

- Testes que dependem de ordem de execução
- Testes que dependem de estado global
- Hardcoded paths ou URLs
- `Sleep()` para coordenação (use channels)
- Testes que modificam arquivos do sistema
- Ignorar erros (sempre valide!)
- Testes lentos (> 5s) sem flag `-short`