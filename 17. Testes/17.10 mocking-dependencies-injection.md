# Mocking e Injeção de Dependências

Mocking permite testar código que depende de recursos externos (databases, APIs, filesystem) sem realmente usá-los. Em Go, mocking é tipicamente feito através de interfaces - você define uma interface para a dependência, usa essa interface no código de produção, e fornece implementações mock nos testes. Isso torna testes rápidos, determinísticos e independentes de serviços externos.

A chave para código testável é **injeção de dependências**: ao invés de criar dependências internamente, receba-as como parâmetros (construtor, método, ou campo da struct). Isso permite injetar mocks nos testes e implementações reais em produção. Evite mocks complexos demais - se seu mock tem muita lógica, pode estar testando o mock ao invés do código real. Bons mocks são simples, focados, e facilitam testes sem adicionar complexidade desnecessária.

## Fundamentos de Injeção de Dependências
```go
package service

import (
    "context"
    "errors"
    "testing"
)

// ❌ RUIM: Dependências criadas internamente (não testável)
type BadUserService struct{}

func (s *BadUserService) CreateUser(name string) error {
    // Cria dependências internamente - impossível mockar!
    db := NewDatabase()  // conexão real
    logger := NewLogger()  // logger real
    
    logger.Info("Creating user")
    return db.Save(&User{Name: name})
}

// ✅ BOM: Dependências injetadas (testável)
type UserService struct {
    db     Database
    logger Logger
}

// Constructor recebe dependências
func NewUserService(db Database, logger Logger) *UserService {
    return &UserService{
        db:     db,
        logger: logger,
    }
}

func (s *UserService) CreateUser(ctx context.Context, name string) error {
    s.logger.Info("Creating user: " + name)
    
    user := &User{Name: name}
    if err := s.db.Save(ctx, user); err != nil {
        s.logger.Error("Failed to save: " + err.Error())
        return err
    }
    
    return nil
}

// Interfaces definem contratos
type Database interface {
    Save(ctx context.Context, user *User) error
    FindByID(ctx context.Context, id int) (*User, error)
}

type Logger interface {
    Info(msg string)
    Error(msg string)
}
```

## Criando Mocks Simples
```go
// Mock básico de Database
type mockDatabase struct {
    saveFunc     func(context.Context, *User) error
    findByIDFunc func(context.Context, int) (*User, error)
}

func (m *mockDatabase) Save(ctx context.Context, user *User) error {
    if m.saveFunc != nil {
        return m.saveFunc(ctx, user)
    }
    return nil  // sucesso por padrão
}

func (m *mockDatabase) FindByID(ctx context.Context, id int) (*User, error) {
    if m.findByIDFunc != nil {
        return m.findByIDFunc(ctx, id)
    }
    return nil, errors.New("not found")
}

// Mock básico de Logger
type mockLogger struct {
    infoMessages  []string
    errorMessages []string
}

func (m *mockLogger) Info(msg string) {
    m.infoMessages = append(m.infoMessages, msg)
}

func (m *mockLogger) Error(msg string) {
    m.errorMessages = append(m.errorMessages, msg)
}

// Teste usando mocks
func TestUserService_CreateUser(t *testing.T) {
    tests := []struct {
        name          string
        userName      string
        dbError       error
        wantErr       bool
        wantInfoLogs  int
        wantErrorLogs int
    }{
        {
            name:          "sucesso",
            userName:      "John",
            dbError:       nil,
            wantErr:       false,
            wantInfoLogs:  1,
            wantErrorLogs: 0,
        },
        {
            name:          "erro ao salvar",
            userName:      "Jane",
            dbError:       errors.New("database error"),
            wantErr:       true,
            wantInfoLogs:  1,
            wantErrorLogs: 1,
        },
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            // Setup mocks
            mockDB := &mockDatabase{
                saveFunc: func(ctx context.Context, user *User) error {
                    // Valida parâmetros
                    if user.Name != tt.userName {
                        t.Errorf("Save chamado com Name = %s; want %s",
                            user.Name, tt.userName)
                    }
                    return tt.dbError
                },
            }
            
            mockLog := &mockLogger{}
            
            // Injeta mocks
            service := NewUserService(mockDB, mockLog)
            
            // Execute
            err := service.CreateUser(context.Background(), tt.userName)
            
            // Validate
            if (err != nil) != tt.wantErr {
                t.Errorf("CreateUser() erro = %v; wantErr %v", err, tt.wantErr)
            }
            
            // Valida logs
            if len(mockLog.infoMessages) != tt.wantInfoLogs {
                t.Errorf("Info logs = %d; want %d", 
                    len(mockLog.infoMessages), tt.wantInfoLogs)
            }
            
            if len(mockLog.errorMessages) != tt.wantErrorLogs {
                t.Errorf("Error logs = %d; want %d",
                    len(mockLog.errorMessages), tt.wantErrorLogs)
            }
        })
    }
}
```

## Mock com Rastreamento de Chamadas
```go
// Mock que rastreia todas as chamadas
type mockDatabaseWithTracking struct {
    saveCalls     []SaveCall
    findByIDCalls []FindByIDCall
}

type SaveCall struct {
    Ctx  context.Context
    User *User
}

type FindByIDCall struct {
    Ctx context.Context
    ID  int
}

func (m *mockDatabaseWithTracking) Save(ctx context.Context, user *User) error {
    m.saveCalls = append(m.saveCalls, SaveCall{Ctx: ctx, User: user})
    return nil
}

func (m *mockDatabaseWithTracking) FindByID(ctx context.Context, id int) (*User, error) {
    m.findByIDCalls = append(m.findByIDCalls, FindByIDCall{Ctx: ctx, ID: id})
    return &User{ID: id}, nil
}

func TestUserService_WithTracking(t *testing.T) {
    mockDB := &mockDatabaseWithTracking{}
    mockLog := &mockLogger{}
    service := NewUserService(mockDB, mockLog)
    
    // Executa múltiplas operações
    service.CreateUser(context.Background(), "User1")
    service.CreateUser(context.Background(), "User2")
    
    // Valida quantas vezes foi chamado
    if len(mockDB.saveCalls) != 2 {
        t.Errorf("Save chamado %d vezes; want 2", len(mockDB.saveCalls))
    }
    
    // Valida parâmetros de cada chamada
    if mockDB.saveCalls[0].User.Name != "User1" {
        t.Errorf("primeira chamada: Name = %s; want User1", 
            mockDB.saveCalls[0].User.Name)
    }
    
    if mockDB.saveCalls[1].User.Name != "User2" {
        t.Errorf("segunda chamada: Name = %s; want User2",
            mockDB.saveCalls[1].User.Name)
    }
}
```

## Mock com Contador de Chamadas
```go
type mockDatabaseWithCounter struct {
    saveCount     int
    findByIDCount int
}

func (m *mockDatabaseWithCounter) Save(ctx context.Context, user *User) error {
    m.saveCount++
    return nil
}

func (m *mockDatabaseWithCounter) FindByID(ctx context.Context, id int) (*User, error) {
    m.findByIDCount++
    return &User{ID: id}, nil
}

func TestCallCounts(t *testing.T) {
    mockDB := &mockDatabaseWithCounter{}
    service := NewUserService(mockDB, &mockLogger{})
    
    // Múltiplas operações
    service.CreateUser(context.Background(), "User1")
    service.CreateUser(context.Background(), "User2")
    service.CreateUser(context.Background(), "User3")
    
    // Valida contador
    if mockDB.saveCount != 3 {
        t.Errorf("Save chamado %d vezes; want 3", mockDB.saveCount)
    }
}
```

## Mock que Simula Atraso (Timeout Testing)
```go
type slowDatabase struct {
    delay time.Duration
}

func (s *slowDatabase) Save(ctx context.Context, user *User) error {
    select {
    case <-time.After(s.delay):
        return nil
    case <-ctx.Done():
        return ctx.Err()
    }
}

func (s *slowDatabase) FindByID(ctx context.Context, id int) (*User, error) {
    select {
    case <-time.After(s.delay):
        return &User{ID: id}, nil
    case <-ctx.Done():
        return nil, ctx.Err()
    }
}

func TestTimeout(t *testing.T) {
    // Mock lento (3 segundos)
    slowDB := &slowDatabase{delay: 3 * time.Second}
    service := NewUserService(slowDB, &mockLogger{})
    
    // Context com timeout de 1 segundo
    ctx, cancel := context.WithTimeout(context.Background(), 1*time.Second)
    defer cancel()
    
    // Deve dar timeout
    err := service.CreateUser(ctx, "Test")
    
    if err == nil {
        t.Error("deveria ter dado timeout")
    }
    
    if !errors.Is(err, context.DeadlineExceeded) {
        t.Errorf("erro = %v; want DeadlineExceeded", err)
    }
}
```

## Mock que Retorna Valores Diferentes
```go
type sequentialMockDatabase struct {
    saveResults []error
    callIndex   int
}

func (m *sequentialMockDatabase) Save(ctx context.Context, user *User) error {
    if m.callIndex >= len(m.saveResults) {
        return errors.New("unexpected call")
    }
    
    result := m.saveResults[m.callIndex]
    m.callIndex++
    return result
}

func (m *sequentialMockDatabase) FindByID(ctx context.Context, id int) (*User, error) {
    return &User{ID: id}, nil
}

func TestSequentialCalls(t *testing.T) {
    // Mock que retorna: sucesso, erro, sucesso
    mockDB := &sequentialMockDatabase{
        saveResults: []error{
            nil,                           // primeira chamada: sucesso
            errors.New("temporary error"), // segunda chamada: erro
            nil,                           // terceira chamada: sucesso
        },
    }
    
    service := NewUserService(mockDB, &mockLogger{})
    
    // Primeira chamada: sucesso
    err := service.CreateUser(context.Background(), "User1")
    if err != nil {
        t.Errorf("primeira chamada deveria ter sucesso, got: %v", err)
    }
    
    // Segunda chamada: erro
    err = service.CreateUser(context.Background(), "User2")
    if err == nil {
        t.Error("segunda chamada deveria retornar erro")
    }
    
    // Terceira chamada: sucesso
    err = service.CreateUser(context.Background(), "User3")
    if err != nil {
        t.Errorf("terceira chamada deveria ter sucesso, got: %v", err)
    }
}
```

## Injeção de Dependências: Diferentes Padrões

### 1. Constructor Injection (Mais comum)
```go
type UserService struct {
    db     Database
    logger Logger
}

// Dependências injetadas no constructor
func NewUserService(db Database, logger Logger) *UserService {
    return &UserService{
        db:     db,
        logger: logger,
    }
}

// Teste
func TestConstructorInjection(t *testing.T) {
    mockDB := &mockDatabase{}
    mockLog := &mockLogger{}
    
    service := NewUserService(mockDB, mockLog)
    // usa service...
}
```

### 2. Method Injection
```go
type UserService struct {
    logger Logger
}

// Dependência injetada como parâmetro do método
func (s *UserService) CreateUser(ctx context.Context, db Database, name string) error {
    s.logger.Info("Creating user")
    return db.Save(ctx, &User{Name: name})
}

// Teste
func TestMethodInjection(t *testing.T) {
    mockDB := &mockDatabase{}
    service := &UserService{logger: &mockLogger{}}
    
    err := service.CreateUser(context.Background(), mockDB, "John")
    // valida...
}
```

### 3. Interface Injection (Functional Options)
```go
type UserService struct {
    db     Database
    logger Logger
}

type Option func(*UserService)

func WithDatabase(db Database) Option {
    return func(s *UserService) {
        s.db = db
    }
}

func WithLogger(logger Logger) Option {
    return func(s *UserService) {
        s.logger = logger
    }
}

func NewUserService(opts ...Option) *UserService {
    s := &UserService{
        db:     &defaultDatabase{},
        logger: &defaultLogger{},
    }
    
    for _, opt := range opts {
        opt(s)
    }
    
    return s
}

// Teste
func TestFunctionalOptions(t *testing.T) {
    mockDB := &mockDatabase{}
    mockLog := &mockLogger{}
    
    service := NewUserService(
        WithDatabase(mockDB),
        WithLogger(mockLog),
    )
    // usa service...
}
```

## Exemplo Completo: Email Service
```go
// Interface
type EmailSender interface {
    Send(to, subject, body string) error
}

// Service que usa email
type NotificationService struct {
    email  EmailSender
    logger Logger
}

func NewNotificationService(email EmailSender, logger Logger) *NotificationService {
    return &NotificationService{
        email:  email,
        logger: logger,
    }
}

func (n *NotificationService) NotifyUser(userEmail, message string) error {
    n.logger.Info("Sending notification to: " + userEmail)
    
    err := n.email.Send(userEmail, "Notification", message)
    if err != nil {
        n.logger.Error("Failed to send email: " + err.Error())
        return err
    }
    
    n.logger.Info("Notification sent successfully")
    return nil
}

// Mock de EmailSender
type mockEmailSender struct {
    sendFunc func(to, subject, body string) error
    calls    []EmailCall
}

type EmailCall struct {
    To      string
    Subject string
    Body    string
}

func (m *mockEmailSender) Send(to, subject, body string) error {
    // Rastreia chamada
    m.calls = append(m.calls, EmailCall{
        To:      to,
        Subject: subject,
        Body:    body,
    })
    
    if m.sendFunc != nil {
        return m.sendFunc(to, subject, body)
    }
    return nil
}

// Teste
func TestNotificationService_NotifyUser(t *testing.T) {
    tests := []struct {
        name       string
        userEmail  string
        message    string
        emailError error
        wantErr    bool
    }{
        {
            name:       "sucesso",
            userEmail:  "user@example.com",
            message:    "Hello!",
            emailError: nil,
            wantErr:    false,
        },
        {
            name:       "falha ao enviar email",
            userEmail:  "user@example.com",
            message:    "Hello!",
            emailError: errors.New("smtp error"),
            wantErr:    true,
        },
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            // Setup mocks
            mockEmail := &mockEmailSender{
                sendFunc: func(to, subject, body string) error {
                    return tt.emailError
                },
            }
            mockLog := &mockLogger{}
            
            // Cria service
            service := NewNotificationService(mockEmail, mockLog)
            
            // Execute
            err := service.NotifyUser(tt.userEmail, tt.message)
            
            // Validate erro
            if (err != nil) != tt.wantErr {
                t.Errorf("NotifyUser() erro = %v; wantErr %v", err, tt.wantErr)
            }
            
            // Valida que email foi chamado
            if len(mockEmail.calls) != 1 {
                t.Fatalf("Send chamado %d vezes; want 1", len(mockEmail.calls))
            }
            
            // Valida parâmetros do email
            call := mockEmail.calls[0]
            if call.To != tt.userEmail {
                t.Errorf("To = %s; want %s", call.To, tt.userEmail)
            }
            if call.Subject != "Notification" {
                t.Errorf("Subject = %s; want Notification", call.Subject)
            }
            if call.Body != tt.message {
                t.Errorf("Body = %s; want %s", call.Body, tt.message)
            }
            
            // Valida logs
            if !tt.wantErr {
                if len(mockLog.infoMessages) != 2 {
                    t.Errorf("Info logs = %d; want 2", len(mockLog.infoMessages))
                }
            } else {
                if len(mockLog.errorMessages) != 1 {
                    t.Errorf("Error logs = %d; want 1", len(mockLog.errorMessages))
                }
            }
        })
    }
}
```

## Testando Retry Logic
```go
type RetryService struct {
    db        Database
    maxRetries int
}

func NewRetryService(db Database, maxRetries int) *RetryService {
    return &RetryService{
        db:         db,
        maxRetries: maxRetries,
    }
}

func (r *RetryService) SaveWithRetry(ctx context.Context, user *User) error {
    var lastErr error
    
    for i := 0; i < r.maxRetries; i++ {
        err := r.db.Save(ctx, user)
        if err == nil {
            return nil  // sucesso
        }
        lastErr = err
        time.Sleep(time.Millisecond * 100)  // backoff
    }
    
    return fmt.Errorf("failed after %d retries: %w", r.maxRetries, lastErr)
}

func TestRetryService_SaveWithRetry(t *testing.T) {
    tests := []struct {
        name        string
        failures    int  // quantas vezes falhar antes de suceder
        maxRetries  int
        wantErr     bool
    }{
        {
            name:       "sucesso na primeira tentativa",
            failures:   0,
            maxRetries: 3,
            wantErr:    false,
        },
        {
            name:       "sucesso na segunda tentativa",
            failures:   1,
            maxRetries: 3,
            wantErr:    false,
        },
        {
            name:       "falha após max retries",
            failures:   5,
            maxRetries: 3,
            wantErr:    true,
        },
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            callCount := 0
            
            mockDB := &mockDatabase{
                saveFunc: func(ctx context.Context, user *User) error {
                    callCount++
                    if callCount <= tt.failures {
                        return errors.New("temporary error")
                    }
                    return nil  // sucesso após N falhas
                },
            }
            
            service := NewRetryService(mockDB, tt.maxRetries)
            err := service.SaveWithRetry(context.Background(), &User{Name: "Test"})
            
            if (err != nil) != tt.wantErr {
                t.Errorf("SaveWithRetry() erro = %v; wantErr %v", err, tt.wantErr)
            }
            
            // Valida número de tentativas
            expectedCalls := tt.failures + 1
            if tt.wantErr {
                expectedCalls = tt.maxRetries
            }
            
            if callCount != expectedCalls {
                t.Errorf("Save chamado %d vezes; want %d", callCount, expectedCalls)
            }
        })
    }
}
```

## Quando Usar Mocks

### ✅ Use mocks quando:

- Dependências externas (DB, APIs, filesystem)
- Código lento ou não-determinístico
- Simular erros difíceis de reproduzir
- Validar que dependências são chamadas corretamente
- Testar lógica de retry, timeout, circuit breaker
- Isolar unidade sendo testada

### ❌ Não use mocks quando:

- Lógica simples sem dependências
- Código que JÁ É uma abstração (não mocke mocks!)
- Mock fica mais complexo que o código real
- Testes de integração (use o real!)
- Testando a própria interface/contrato
- Código trivial (getters, setters)

## Boas Práticas
```
✅ Interfaces pequenas e focadas
✅ Um mock por dependência
✅ Mocks simples e legíveis
✅ Rastreie chamadas quando necessário
✅ Valide parâmetros passados ao mock
✅ Use functional options para flexibilidade
✅ Documente comportamento do mock

❌ Não crie mocks complexos com muita lógica
❌ Não mocke tudo (over-mocking)
❌ Não teste o mock ao invés do código
❌ Não compartilhe mocks entre testes
❌ Não ignore o que o mock faz
❌ Não force injeção onde não precisa
```

## Checklist
```
□ Código usa interfaces para dependências
□ Dependências são injetadas (não criadas internamente)
□ Mocks implementam interfaces completamente
□ Mocks rastreiam chamadas quando necessário
□ Testes validam parâmetros passados aos mocks
□ Testes validam número de chamadas quando relevante
□ Mocks são simples e focados
□ Não há over-mocking
□ Testes de integração usam implementações reais
□ Código de produção não conhece mocks
```