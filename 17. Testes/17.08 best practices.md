# Organização e Best Practices

Organizar testes de forma consistente facilita manutenção, descoberta e colaboração. Go tem convenções claras: testes no mesmo package do código (acesso a privados), arquivos `*_test.go`, helpers em arquivo separado. Para projetos maiores, considere subpackage `testutil` para helpers reutilizados em múltiplos packages. A estrutura de pastas deve espelhar o código de produção.

Bons testes são legíveis, independentes e rápidos. Use nomes descritivos que documentam o comportamento esperado. Evite dependências entre testes - cada um deve poder rodar isoladamente. Prefira testes unitários rápidos; reserve testes de integração (mais lentos) para CI/CD. Comentários em testes devem explicar **por que**, não **o que** (o código já mostra o que). A organização correta dos testes é tão importante quanto escrevê-los - testes desorganizados são testes que ninguém mantém.

## Estrutura de Diretórios
```
myapp/
├── http.go              // código de produção
├── http_test.go         // testes de http.go
├── parser.go
├── parser_test.go
├── testing.go           // helpers compartilhados (mesmo package)
│
├── internal/
│   ├── database/
│   │   ├── db.go
│   │   ├── db_test.go
│   │   └── testing.go   // helpers específicos de database
│   │
│   └── api/
│       ├── handlers.go
│       ├── handlers_test.go
│       └── fixtures.go  // dados de teste (fixtures)
│
└── testutil/            // helpers para múltiplos packages (opcional)
    └── http.go          // helpers HTTP reutilizáveis
```

## Nomenclatura de Arquivos
```go
// ✅ Padrão correto
codigo.go       → codigo_test.go      // mesmo nome + _test
helpers.go      → helpers_test.go
user.go         → user_test.go

// Arquivos especiais de teste
testing.go          // helpers compartilhados (sem _test)
test_helpers.go     // alternativa para helpers
fixtures.go         // dados de teste
testdata/          // diretório especial (Go ignora no build)

// ❌ Padrões incorretos
test_codigo.go     // não é o padrão Go
codigo_tests.go    // plural não é padrão
codigoTest.go      // capitalização errada
```

## Package Declaration
```go
// Mesma package (testa código privado e público)
package myapp

import "testing"

func TestInternalFunction(t *testing.T) {
    // Pode acessar funções/variáveis privadas
    result := internalHelper("test")
    if result != expected {
        t.Error("falhou")
    }
}

// Package externa (testa apenas API pública)
package myapp_test

import (
    "testing"
    "myapp"  // precisa importar
)

func TestPublicAPI(t *testing.T) {
    // Só acessa API pública
    result := myapp.Parse("test")
    if result != expected {
        t.Error("falhou")
    }
}

// Use package externa quando:
// - Quer testar apenas interface pública
// - Evitar dependências circulares
// - Documentar uso da API
// - Forçar uso apenas de exports
```

## Nomenclatura de Funções de Teste
```go
// ✅ Padrões corretos
func TestAdd(t *testing.T)                      // função simples
func TestAdd_PositiveNumbers(t *testing.T)      // cenário específico
func TestAdd_ReturnsZeroForEmptyInput(t *testing.T)  // comportamento
func TestUserRepository_Create(t *testing.T)    // método de struct
func TestUserRepository_Create_DuplicateEmail(t *testing.T)  // cenário do método

// ❌ Padrões incorretos
func Test_add(t *testing.T)                     // não começa com maiúscula
func testAdd(t *testing.T)                      // não começa com Test
func TestAddFunction(t *testing.T)              // redundante ("Function")
func test1(t *testing.T)                        // não começa com Test
```

## Nomenclatura de Subtests
```go
func TestUserOperations(t *testing.T) {
    tests := []struct {
        name string
        // ...
    }{
        // ✅ Bons nomes
        {name: "empty input"},              // snake_case ou palavras
        {name: "valid email"},              // descrição clara
        {name: "returns error on nil"},     // comportamento esperado
        {name: "special characters in name"}, // caso específico
        
        // ❌ Nomes ruins
        {name: "test1"},                    // genérico
        {name: "EmptyInput"},               // PascalCase (prefira minúscula)
        {name: "t1"},                       // não descritivo
        {name: ""},                         // vazio
    }
}
```

## Comentários em Testes
```go
// ✅ BOM: explica POR QUÊ
func TestDivide(t *testing.T) {
    // Precisamos testar divisão por zero porque é o erro mais comum
    // que usuários encontram em produção. Bug #1234 foi causado por
    // não validar divisor zero.
    _, err := Divide(10, 0)
    if err == nil {
        t.Error("deveria retornar erro")
    }
}

// ❌ RUIM: repete o óbvio
func TestDivide(t *testing.T) {
    // Chama Divide com 10 e 0
    result, err := Divide(10, 0)
    // Verifica se tem erro
    if err == nil {
        t.Error("deveria retornar erro")
    }
}

// ✅ BOM: documenta decisão de design
func TestCache_Expiration(t *testing.T) {
    // Timeout de 1ms para forçar expiração rápida no teste.
    // Em produção, usa 1 hora (definido em config).
    cache := NewCache(1 * time.Millisecond)
    // ...
}

// ✅ BOM: explica workaround
func TestAPI_RateLimit(t *testing.T) {
    // TODO: Mock do rate limiter está retornando erro errado.
    // Por enquanto, apenas verificamos que erro não é nil.
    // Fix em #5678
    _, err := api.Call()
    if err == nil {
        t.Error("esperava erro de rate limit")
    }
}
```

## Ordem de Asserções (Padrão AAA)
```go
func TestUserService_Create(t *testing.T) {
    // ARRANGE - preparar dados/estado
    db := setupTestDB(t)
    service := NewUserService(db)
    user := &User{
        Name:  "John",
        Email: "john@example.com",
    }
    
    // ACT - executar a ação
    err := service.Create(user)
    
    // ASSERT - validar resultado
    // 1. Erro primeiro (se aplicável)
    if err != nil {
        t.Fatalf("Create falhou: %v", err)
    }
    
    // 2. Resultado depois
    if user.ID == 0 {
        t.Error("ID não foi setado")
    }
    
    // 3. Efeitos colaterais
    found, _ := service.FindByEmail("john@example.com")
    if found == nil {
        t.Error("usuário não foi salvo")
    }
}
```

## t.Error() vs t.Fatal()
```go
// Use t.Error() quando:
// - Múltiplas asserções no mesmo teste
// - Erro não impede asserções seguintes
func TestMultipleAssertions(t *testing.T) {
    user := GetUser()
    
    // Verifica múltiplos campos
    if user.Name != "John" {
        t.Error("nome errado")  // ← continua testando
    }
    
    if user.Age != 30 {
        t.Error("idade errada")  // ← continua testando
    }
    
    if user.Email == "" {
        t.Error("email vazio")  // ← continua testando
    }
    
    // Vê TODOS os erros de uma vez
}

// Use t.Fatal() quando:
// - Erro impede continuação (ex: err != nil)
// - Setup falhou
// - Pré-condição não foi atendida
func TestWithSetup(t *testing.T) {
    db, err := SetupDatabase()
    if err != nil {
        t.Fatal("setup falhou:", err)  // ← para imediatamente
    }
    // Sem db, resto não faz sentido
    
    user := &User{Name: "John"}
    if err := db.Save(user); err != nil {
        t.Fatal("save falhou:", err)  // ← para imediatamente
    }
    // Sem save, próximas operações falharão
    
    // Testes que dependem de db e user salvo
}

// Use t.Errorf() para mensagens formatadas
func TestWithFormatting(t *testing.T) {
    got := Calculate(10, 5)
    want := 15
    
    if got != want {
        t.Errorf("Calculate(10, 5) = %d; want %d", got, want)
    }
}

// Use t.Fatalf() para erros críticos formatados
func TestCriticalError(t *testing.T) {
    result, err := CriticalOperation()
    if err != nil {
        t.Fatalf("CriticalOperation() falhou: %v (result: %v)", err, result)
    }
}
```

## Paralelização (Avançado)
```go
func TestParallel(t *testing.T) {
    tests := []struct {
        name  string
        input int
        want  int
    }{
        {"caso1", 1, 2},
        {"caso2", 2, 4},
        {"caso3", 3, 6},
    }
    
    for _, tt := range tests {
        tt := tt  // captura variável do loop (Go < 1.22)
        
        t.Run(tt.name, func(t *testing.T) {
            t.Parallel()  // marca como paralelo
            
            // Este teste roda em paralelo com outros
            result := Process(tt.input)
            
            if result != tt.want {
                t.Errorf("Process(%d) = %d; want %d", 
                    tt.input, result, tt.want)
            }
        })
    }
}

// CUIDADO com t.Parallel():
// ✅ Use se testes são independentes
// ✅ Use se não compartilham recursos
// ❌ Não use se compartilham DB, arquivos, variáveis globais
// ❌ Não use se testes modificam estado compartilhado
// ⚠️ Aumenta velocidade mas complica debugging
```

## Build Tags para Testes Especiais
```go
//go:build integration
// +build integration

package myapp_test

import "testing"

// Este arquivo só compila com: go test -tags=integration

func TestDatabaseIntegration(t *testing.T) {
    // Teste lento que precisa de DB real
    db := ConnectRealDatabase()
    defer db.Close()
    
    // testes de integração...
}

// Útil para:
// - Testes lentos (integração, E2E)
// - Testes que precisam de recursos externos (DB, APIs)
// - Separar testes rápidos dos lentos

// Executar:
// go test                    # roda apenas testes normais
// go test -tags=integration  # roda testes de integração também
// go test -short             # pula testes longos (usa testing.Short())
```

## Testando Panics
```go
func TestPanic(t *testing.T) {
    defer func() {
        if r := recover(); r == nil {
            t.Error("deveria ter dado panic")
        }
    }()
    
    FunctionThatPanics()
}

// Ou use helper
func assertPanic(t *testing.T, f func(), msg string) {
    t.Helper()
    
    defer func() {
        if r := recover(); r == nil {
            t.Error(msg)
        }
    }()
    
    f()
}

// Uso
func TestDivideByZeroPanics(t *testing.T) {
    assertPanic(t, func() {
        MustDivide(10, 0)
    }, "MustDivide(10, 0) deveria dar panic")
}
```

## Testando Código Concorrente
```go
func TestConcurrent(t *testing.T) {
    const goroutines = 100
    done := make(chan bool, goroutines)
    errors := make(chan error, goroutines)
    
    for i := 0; i < goroutines; i++ {
        go func(id int) {
            // código concorrente
            result, err := ConcurrentFunction(id)
            if err != nil {
                errors <- err
            } else if result != expected {
                errors <- fmt.Errorf("goroutine %d: got %v; want %v", 
                    id, result, expected)
            }
            done <- true
        }(i)
    }
    
    // Aguarda todas as goroutines
    for i := 0; i < goroutines; i++ {
        <-done
    }
    
    // Verifica erros
    close(errors)
    for err := range errors {
        t.Error(err)
    }
}

// Detectar race conditions
// go test -race
```

## Golden Files (Arquivos de Referência)
```go
func TestRenderTemplate(t *testing.T) {
    data := TemplateData{Title: "Test", Items: []string{"a", "b"}}
    output := RenderTemplate(data)
    
    // Salva output em arquivo (primeira vez)
    goldenFile := "testdata/template.golden"
    
    // Flag -update para atualizar golden files
    if *update {
        os.WriteFile(goldenFile, []byte(output), 0644)
    }
    
    // Compara com golden file
    expected, err := os.ReadFile(goldenFile)
    if err != nil {
        t.Fatal(err)
    }
    
    if output != string(expected) {
        t.Errorf("output difere do golden file")
        t.Logf("Output:\n%s", output)
    }
}

// Para atualizar golden files:
// go test -update (requer adicionar flag no código)

var update = flag.Bool("update", false, "update golden files")
```

## Estrutura testdata/
```
myapp/
├── parser.go
├── parser_test.go
└── testdata/           // Go ignora este diretório no build
    ├── input1.json
    ├── input2.xml
    └── expected.golden

// testdata/ é especial:
// - Go não compila arquivos aqui
// - Perfeito para fixtures, golden files
// - Comprometido no git
// - Acessível via paths relativos nos testes
```

## Exemplo: Organização Completa
```go
// arquivo: testing.go (helpers compartilhados)
package myapp

import (
    "net/http/httptest"
    "testing"
)

func newTestServer(t *testing.T, handler http.HandlerFunc) (*httptest.Server, *http.Client) {
    t.Helper()
    server := httptest.NewServer(handler)
    return server, server.Client()
}

func checkError(t *testing.T, err error, wantErr bool, errorMsg string) {
    t.Helper()
    // implementação...
}

// arquivo: user_test.go (testes)
package myapp

import "testing"

func TestUser_Validate(t *testing.T) {
    tests := []struct {
        name    string
        user    *User
        wantErr bool
    }{
        // casos de teste...
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            err := tt.user.Validate()
            checkError(t, err, tt.wantErr, "")
        })
    }
}

// arquivo: fixtures.go (dados de teste)
package myapp

func newTestUser() *User {
    return &User{
        ID:    1,
        Name:  "Test User",
        Email: "test@example.com",
    }
}
```

## Checklist de Boas Práticas
```
✅ Estrutura e Organização
□ Um arquivo *_test.go por arquivo de código
□ Helpers em testing.go (package level)
□ Fixtures em arquivo separado se necessário
□ testdata/ para arquivos externos

✅ Nomenclatura
□ Nomes descritivos (função e subtests)
□ TestFunctionName ou TestStructName_MethodName
□ Subtests em minúscula, descritivos

✅ Código
□ Table-driven tests com t.Run()
□ Testes independentes (sem ordem)
□ Setup/teardown com defer ou t.Cleanup()
□ t.Helper() em funções auxiliares

✅ Asserções
□ Use t.Error() para múltiplas validações
□ Use t.Fatal() quando erro impede continuação
□ Valida erro antes de resultado
□ Mensagens claras com contexto

✅ Comentários
□ Explicam "por quê", não "o quê"
□ Documentam decisões não óbvias
□ Referenciam bugs/issues quando relevante

✅ Performance
□ Testes rápidos (< 1s cada, idealmente)
□ Use t.Parallel() com cuidado
□ Testes lentos com -tags ou -short

❌ Evite
□ Testes dependentes de ordem
□ Hardcoded paths/URLs
□ Sleep() para timing (use channels/contexts)
□ Testar implementação ao invés de comportamento
□ Estado global compartilhado
□ 100% de cobertura a qualquer custo
```