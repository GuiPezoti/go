# Helpers de Teste e t.Helper()

Helpers de teste são funções auxiliares que reduzem código duplicado nos testes. Quando você encontra o mesmo setup, validação ou teardown repetido em vários testes, é hora de extrair um helper. A função `t.Helper()` é crucial: ela marca a função como helper, fazendo com que erros reportem a linha que **chamou** o helper, não a linha **dentro** do helper. Isso facilita muito o debugging.

Organize helpers em um arquivo separado (ex: `testing.go` ou `test_helpers.go`) no mesmo package dos testes. Como está no mesmo package, não precisa de imports extras. Helpers devem fazer uma coisa bem feita: criar mocks, validar erros, comparar resultados, etc. Evite helpers que fazem muitas coisas ou têm muitos parâmetros - mantenha-os simples e focados. Bons helpers tornam testes mais legíveis e manuteníveis.
```go
// arquivo: testing.go (helpers compartilhados)
package myapp

import (
    "bytes"
    "net/http"
    "net/http/httptest"
    "strings"
    "testing"
)

// Helper para criar servidor HTTP mock
func newTestServer(t *testing.T, handler http.HandlerFunc) (*httptest.Server, *http.Client) {
    t.Helper()  // CRÍTICO: marca como helper para melhor debugging
    
    server := httptest.NewServer(handler)
    return server, server.Client()
}

// Helper para validar erros
func checkError(t *testing.T, err error, wantErr bool, errorMsg string) {
    t.Helper()
    
    if wantErr {
        // Esperava erro
        if err == nil {
            t.Error("esperava erro, mas não ocorreu")
            return
        }
        // Valida mensagem se especificada
        if errorMsg != "" && !strings.Contains(err.Error(), errorMsg) {
            t.Errorf("erro = %q; deveria conter %q", err.Error(), errorMsg)
        }
        return
    }
    
    // Não esperava erro
    if err != nil {
        t.Errorf("erro inesperado: %v", err)
    }
}

// Helper para comparar slices de bytes
func assertBytesEqual(t *testing.T, got, want []byte) {
    t.Helper()
    
    if !bytes.Equal(got, want) {
        t.Errorf("bytes diferentes:\ngot:  %q\nwant: %q", got, want)
    }
}

// Helper para comparar strings
func assertEqual(t *testing.T, got, want string) {
    t.Helper()
    
    if got != want {
        t.Errorf("got %q; want %q", got, want)
    }
}

// Helper para comparar inteiros
func assertIntEqual(t *testing.T, got, want int) {
    t.Helper()
    
    if got != want {
        t.Errorf("got %d; want %d", got, want)
    }
}

// Helper para validar que algo não é nil
func assertNotNil(t *testing.T, value interface{}, name string) {
    t.Helper()
    
    if value == nil {
        t.Errorf("%s é nil", name)
    }
}

// Helper para setup de contexto com timeout
func newTestContext(t *testing.T, timeout time.Duration) context.Context {
    t.Helper()
    
    ctx, cancel := context.WithTimeout(context.Background(), timeout)
    t.Cleanup(cancel)  // Garante que cancela quando teste termina
    
    return ctx
}

// Helper para criar usuário de teste
func newTestUser(name, email string) *User {
    return &User{
        ID:        1,
        Name:      name,
        Email:     email,
        CreatedAt: time.Now(),
    }
}

// Helper para criar database mock
func newTestDB(t *testing.T) *DB {
    t.Helper()
    
    db, err := OpenTestDB()
    if err != nil {
        t.Fatalf("falha ao criar test DB: %v", err)
    }
    
    // Cleanup automático
    t.Cleanup(func() {
        db.Close()
    })
    
    return db
}

// arquivo: myapp_test.go (usando os helpers)
package myapp

import (
    "context"
    "net/http"
    "testing"
)

func TestFetchData(t *testing.T) {
    tests := []struct {
        name       string
        mockStatus int
        mockBody   []byte
        wantErr    bool
        errorMsg   string
    }{
        {
            name:       "sucesso",
            mockStatus: http.StatusOK,
            mockBody:   []byte("data"),
            wantErr:    false,
        },
        {
            name:       "erro 404",
            mockStatus: http.StatusNotFound,
            mockBody:   []byte("not found"),
            wantErr:    true,
            errorMsg:   "Status: 404",
        },
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            // USA O HELPER - código limpo!
            server, client := newTestServer(t, func(w http.ResponseWriter, r *http.Request) {
                w.WriteHeader(tt.mockStatus)
                w.Write(tt.mockBody)
            })
            defer server.Close()
            
            got, err := FetchData(context.Background(), client, server.URL)
            
            // USA O HELPER - validação limpa!
            checkError(t, err, tt.wantErr, tt.errorMsg)
            if tt.wantErr {
                return  // Para se esperava erro
            }
            
            // USA O HELPER - comparação limpa!
            assertBytesEqual(t, got, tt.mockBody)
        })
    }
}

// Exemplo sem helper vs com helper

// ❌ SEM HELPER (repetitivo)
func TestAdd_WithoutHelper(t *testing.T) {
    result := Add(2, 3)
    expected := 5
    
    if result != expected {
        t.Errorf("Add(2, 3) = %d; want %d", result, expected)
    }
    
    result = Add(10, 20)
    expected = 30
    
    if result != expected {
        t.Errorf("Add(10, 20) = %d; want %d", result, expected)
    }
}

// ✅ COM HELPER (limpo)
func TestAdd_WithHelper(t *testing.T) {
    assertIntEqual(t, Add(2, 3), 5)
    assertIntEqual(t, Add(10, 20), 30)
}

// Helper que retorna bool (padrão alternativo)
func validateError(t *testing.T, err error, wantErr bool) bool {
    t.Helper()
    
    if wantErr {
        if err == nil {
            t.Error("esperava erro")
        }
        return true  // retorna true = era caso de erro, teste deve parar
    }
    
    if err != nil {
        t.Errorf("erro inesperado: %v", err)
    }
    
    return false  // retorna false = não era erro, teste continua
}

// Usando helper que retorna bool
func TestWithBoolHelper(t *testing.T) {
    result, err := DoSomething()
    
    if validateError(t, err, false) {
        return  // para se era caso de erro
    }
    
    // continua validando resultado
    assertEqual(t, result, "expected")
}

// t.Cleanup() - alternativa ao defer
func TestComCleanup(t *testing.T) {
    // Setup
    tempFile, err := os.CreateTemp("", "test")
    if err != nil {
        t.Fatal(err)
    }
    
    // Cleanup registrado - executa ao final do teste
    t.Cleanup(func() {
        os.Remove(tempFile.Name())
    })
    
    // Múltiplos cleanups são executados em ordem reversa (LIFO)
    t.Cleanup(func() {
        fmt.Println("Segundo cleanup")
    })
    
    t.Cleanup(func() {
        fmt.Println("Primeiro cleanup (executa por último)")
    })
    
    // ... resto do teste
}

// Helper com t.Cleanup integrado
func createTempFile(t *testing.T, content string) string {
    t.Helper()
    
    file, err := os.CreateTemp("", "test")
    if err != nil {
        t.Fatalf("falha ao criar arquivo: %v", err)
    }
    
    // Cleanup automático
    t.Cleanup(func() {
        os.Remove(file.Name())
    })
    
    if _, err := file.WriteString(content); err != nil {
        t.Fatalf("falha ao escrever: %v", err)
    }
    
    file.Close()
    return file.Name()
}

// Usando helper com cleanup
func TestWithTempFile(t *testing.T) {
    filename := createTempFile(t, "test content")
    
    // Usa o arquivo
    data, err := os.ReadFile(filename)
    if err != nil {
        t.Fatalf("erro ao ler: %v", err)
    }
    
    assertEqual(t, string(data), "test content")
    
    // Não precisa cleanup manual - helper já registrou!
}

// Helper parametrizado (flexível)
func newTestUserWithAge(t *testing.T, age int) *User {
    t.Helper()
    
    if age < 0 {
        t.Fatal("idade não pode ser negativa")
    }
    
    return &User{
        ID:    1,
        Name:  "Test User",
        Email: "test@example.com",
        Age:   age,
    }
}

// Helper com múltiplas variações
func newAdminUser(t *testing.T) *User {
    t.Helper()
    
    user := newTestUser("Admin", "admin@example.com")
    user.IsAdmin = true
    return user
}

func newMinorUser(t *testing.T) *User {
    t.Helper()
    
    return newTestUserWithAge(t, 15)
}

// Helper para comparar structs
func assertUserEqual(t *testing.T, got, want *User) {
    t.Helper()
    
    if got.Name != want.Name {
        t.Errorf("Name = %q; want %q", got.Name, want.Name)
    }
    
    if got.Email != want.Email {
        t.Errorf("Email = %q; want %q", got.Email, want.Email)
    }
    
    if got.Age != want.Age {
        t.Errorf("Age = %d; want %d", got.Age, want.Age)
    }
}

// Helper para validar slice vazio
func assertEmpty(t *testing.T, slice interface{}) {
    t.Helper()
    
    v := reflect.ValueOf(slice)
    if v.Len() != 0 {
        t.Errorf("slice não está vazio: len = %d", v.Len())
    }
}

// Helper para validar slice não vazio
func assertNotEmpty(t *testing.T, slice interface{}) {
    t.Helper()
    
    v := reflect.ValueOf(slice)
    if v.Len() == 0 {
        t.Error("slice está vazio")
    }
}

// Helper para comparar slices
func assertSliceEqual(t *testing.T, got, want []string) {
    t.Helper()
    
    if len(got) != len(want) {
        t.Errorf("len = %d; want %d", len(got), len(want))
        return
    }
    
    for i := range got {
        if got[i] != want[i] {
            t.Errorf("index %d: got %q; want %q", i, got[i], want[i])
        }
    }
}

// Helper para validar panic
func assertPanic(t *testing.T, f func()) {
    t.Helper()
    
    defer func() {
        if r := recover(); r == nil {
            t.Error("deveria ter dado panic")
        }
    }()
    
    f()
}

// Usando assertPanic
func TestDivideByZeroPanics(t *testing.T) {
    assertPanic(t, func() {
        MustDivide(10, 0)  // deve dar panic
    })
}

// Helper para mock de logger
type testLogger struct {
    messages []string
}

func (l *testLogger) Log(msg string) {
    l.messages = append(l.messages, msg)
}

func newTestLogger() *testLogger {
    return &testLogger{
        messages: make([]string, 0),
    }
}

func (l *testLogger) assertLogged(t *testing.T, expected string) {
    t.Helper()
    
    for _, msg := range l.messages {
        if strings.Contains(msg, expected) {
            return
        }
    }
    
    t.Errorf("mensagem %q não foi logada. Logs: %v", expected, l.messages)
}

// Usando logger mock
func TestWithLogger(t *testing.T) {
    logger := newTestLogger()
    
    service := NewService(logger)
    service.DoSomething()
    
    logger.assertLogged(t, "operation completed")
}

// Helper com contador de chamadas
type callCounter struct {
    count int
}

func (c *callCounter) increment() {
    c.count++
}

func (c *callCounter) assertCalled(t *testing.T, expected int) {
    t.Helper()
    
    if c.count != expected {
        t.Errorf("função chamada %d vezes; want %d", c.count, expected)
    }
}

// Helper para comparar JSON
func assertJSONEqual(t *testing.T, got, want string) {
    t.Helper()
    
    var gotJSON, wantJSON interface{}
    
    if err := json.Unmarshal([]byte(got), &gotJSON); err != nil {
        t.Fatalf("JSON inválido em 'got': %v", err)
    }
    
    if err := json.Unmarshal([]byte(want), &wantJSON); err != nil {
        t.Fatalf("JSON inválido em 'want': %v", err)
    }
    
    if !reflect.DeepEqual(gotJSON, wantJSON) {
        t.Errorf("JSON diferente:\ngot:  %s\nwant: %s", got, want)
    }
}

// Helper para carregar fixture de arquivo
func loadFixture(t *testing.T, filename string) []byte {
    t.Helper()
    
    data, err := os.ReadFile(filepath.Join("testdata", filename))
    if err != nil {
        t.Fatalf("falha ao carregar fixture %s: %v", filename, err)
    }
    
    return data
}

// Usando fixture loader
func TestWithFixture(t *testing.T) {
    jsonData := loadFixture(t, "user.json")
    
    var user User
    if err := json.Unmarshal(jsonData, &user); err != nil {
        t.Fatalf("unmarshal falhou: %v", err)
    }
    
    assertEqual(t, user.Name, "John Doe")
}
```

## Por Que t.Helper() É Importante
```go
// SEM t.Helper()
func badHelper(t *testing.T, got, want int) {
    // t.Helper() está faltando!
    
    if got != want {
        t.Errorf("got %d; want %d", got, want)
    }
}

func TestWithBadHelper(t *testing.T) {
    result := Add(2, 3)
    badHelper(t, result, 5)
}

// Output do erro:
// helper.go:45: got 4; want 5  ← aponta para DENTRO do helper (confuso!)

// COM t.Helper()
func goodHelper(t *testing.T, got, want int) {
    t.Helper()  // ← ADICIONA ISTO!
    
    if got != want {
        t.Errorf("got %d; want %d", got, want)
    }
}

func TestWithGoodHelper(t *testing.T) {
    result := Add(2, 3)
    goodHelper(t, result, 5)
}

// Output do erro:
// test.go:15: got 4; want 5  ← aponta para ONDE chamou o helper (claro!)
```

## Quando Criar Helpers

### ✅ Crie helper quando:

- Código repetido em 3+ testes
- Setup/teardown complexo
- Validações com lógica
- Criação de mocks/fixtures
- Comparações complexas
- Padrão claro emerge

### ❌ Não crie helper quando:

- Usado apenas 1-2 vezes
- Lógica muito simples (1-2 linhas)
- Helper ficaria muito genérico (muitos parâmetros)
- Esconderia lógica importante do teste
- Criaria mais confusão que clareza

## Organização de Helpers
```
myapp/
├── user.go
├── user_test.go
├── order.go
├── order_test.go
└── testing.go        ← helpers compartilhados aqui

ou

myapp/
├── user.go
├── user_test.go
├── user_helpers_test.go   ← helpers específicos de user
├── order.go
├── order_test.go
├── order_helpers_test.go  ← helpers específicos de order
└── testing.go             ← helpers globais
```

## Boas Práticas
```go
// ✅ Nome descritivo
func assertUserValid(t *testing.T, user *User) { ... }

// ❌ Nome genérico
func check(t *testing.T, thing interface{}) { ... }

// ✅ Foco único
func assertEqual(t *testing.T, got, want string) { ... }

// ❌ Faz muitas coisas
func setupAndValidateEverything(t *testing.T, ...) { ... }

// ✅ Sempre use t.Helper()
func myHelper(t *testing.T) {
    t.Helper()  // NUNCA esqueça!
    ...
}

// ✅ Use t.Cleanup() para teardown
func createResource(t *testing.T) *Resource {
    t.Helper()
    resource := New()
    t.Cleanup(func() { resource.Close() })
    return resource
}
```