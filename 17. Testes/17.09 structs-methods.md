# Testando Structs e Métodos

Testar structs e seus métodos requer atenção especial à inicialização, estado interno e side effects. Diferente de funções puras, métodos podem modificar o estado do receiver, interagir com dependências externas, ou ter comportamento que depende de chamadas anteriores. A chave é isolar cada teste, criar instâncias frescas para cada caso, e usar injeção de dependências para facilitar mocking.

Ao testar métodos, considere tanto o método individual quanto a interação entre múltiplos métodos. Teste que métodos modificam o estado esperado, que getters retornam valores corretos após setters, e que métodos com side effects (IO, rede, etc) podem ser mockados. Use pointer receivers quando o método precisa modificar o receiver, e value receivers quando não precisa. Testes de structs devem validar não apenas comportamento individual, mas também o ciclo de vida completo do objeto.
```go
package user

import (
    "errors"
    "testing"
    "time"
)

// Struct que queremos testar
type User struct {
    ID        int
    Name      string
    Email     string
    Age       int
    CreatedAt time.Time
}

// Métodos
func (u *User) IsAdult() bool {
    return u.Age >= 18
}

func (u *User) UpdateEmail(email string) error {
    if email == "" {
        return errors.New("email vazio")
    }
    u.Email = email
    return nil
}

func (u *User) FullInfo() string {
    return fmt.Sprintf("%s (%s)", u.Name, u.Email)
}

func (u *User) IsValid() error {
    if u.Name == "" {
        return errors.New("nome vazio")
    }
    if u.Email == "" {
        return errors.New("email vazio")
    }
    if u.Age < 0 {
        return errors.New("idade inválida")
    }
    return nil
}

// Teste básico de método
func TestUser_IsAdult(t *testing.T) {
    tests := []struct {
        name string
        age  int
        want bool
    }{
        {"menor de idade", 10, false},
        {"exatamente 18", 18, true},
        {"adulto", 25, true},
        {"zero", 0, false},
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            // Nova instância para cada teste
            user := &User{Age: tt.age}
            
            got := user.IsAdult()
            
            if got != tt.want {
                t.Errorf("IsAdult() = %v; want %v", got, tt.want)
            }
        })
    }
}

// Testando método que modifica estado
func TestUser_UpdateEmail(t *testing.T) {
    tests := []struct {
        name      string
        email     string
        wantErr   bool
        wantEmail string
    }{
        {
            name:      "email válido",
            email:     "new@example.com",
            wantErr:   false,
            wantEmail: "new@example.com",
        },
        {
            name:      "email vazio",
            email:     "",
            wantErr:   true,
            wantEmail: "old@example.com",  // não deve mudar
        },
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            // Setup: cria user com email inicial
            user := &User{
                Name:  "John",
                Email: "old@example.com",
            }
            
            // Execute
            err := user.UpdateEmail(tt.email)
            
            // Validate erro
            if (err != nil) != tt.wantErr {
                t.Errorf("UpdateEmail() erro = %v; wantErr %v", err, tt.wantErr)
            }
            
            // Validate estado foi modificado corretamente
            if user.Email != tt.wantEmail {
                t.Errorf("Email = %s; want %s", user.Email, tt.wantEmail)
            }
        })
    }
}

// Testando múltiplos métodos em sequência
func TestUser_Workflow(t *testing.T) {
    // Cria user
    user := &User{
        Name:  "John",
        Email: "john@example.com",
        Age:   25,
    }
    
    // Testa estado inicial
    if !user.IsAdult() {
        t.Error("deveria ser adulto")
    }
    
    // Modifica email
    err := user.UpdateEmail("newemail@example.com")
    if err != nil {
        t.Fatalf("UpdateEmail falhou: %v", err)
    }
    
    // Verifica que modificação funcionou
    info := user.FullInfo()
    expected := "John (newemail@example.com)"
    if info != expected {
        t.Errorf("FullInfo() = %q; want %q", info, expected)
    }
    
    // Valida estado final
    if err := user.IsValid(); err != nil {
        t.Errorf("user deveria ser válido: %v", err)
    }
}

// Testando struct com dependências
type UserService struct {
    repo   Repository  // dependência externa
    logger Logger
}

func NewUserService(repo Repository, logger Logger) *UserService {
    return &UserService{
        repo:   repo,
        logger: logger,
    }
}

func (s *UserService) CreateUser(name, email string) (*User, error) {
    s.logger.Info("Creating user: " + name)
    
    user := &User{Name: name, Email: email}
    
    // Valida
    if err := user.IsValid(); err != nil {
        s.logger.Error("Validation failed: " + err.Error())
        return nil, err
    }
    
    // Salva
    if err := s.repo.Save(user); err != nil {
        s.logger.Error("Save failed: " + err.Error())
        return nil, err
    }
    
    return user, nil
}

// Interface para permitir mock
type Repository interface {
    Save(user *User) error
    FindByEmail(email string) (*User, error)
}

type Logger interface {
    Info(msg string)
    Error(msg string)
}

// Mock do repository
type mockRepository struct {
    saveFunc        func(*User) error
    findByEmailFunc func(string) (*User, error)
}

func (m *mockRepository) Save(user *User) error {
    if m.saveFunc != nil {
        return m.saveFunc(user)
    }
    return nil  // sucesso por padrão
}

func (m *mockRepository) FindByEmail(email string) (*User, error) {
    if m.findByEmailFunc != nil {
        return m.findByEmailFunc(email)
    }
    return nil, errors.New("not found")
}

// Mock do logger
type mockLogger struct {
    infoMessages  []string
    errorMessages []string
}

func (m *mockLogger) Info(msg string) {
    m.infoMessages = append(m.infoMessages, msg)
}

func (m *mockLogger) Error(msg string) {
    m.errorMessages = append(m.errorMessages, msg)
}

// Testando com mocks
func TestUserService_CreateUser(t *testing.T) {
    tests := []struct {
        name          string
        userName      string
        userEmail     string
        repoError     error  // erro que mock deve retornar
        wantErr       bool
        wantInfoLogs  int
        wantErrorLogs int
    }{
        {
            name:          "sucesso",
            userName:      "John",
            userEmail:     "john@example.com",
            repoError:     nil,
            wantErr:       false,
            wantInfoLogs:  1,
            wantErrorLogs: 0,
        },
        {
            name:          "erro ao salvar",
            userName:      "Jane",
            userEmail:     "jane@example.com",
            repoError:     errors.New("database error"),
            wantErr:       true,
            wantInfoLogs:  1,
            wantErrorLogs: 1,
        },
        {
            name:          "validação falha",
            userName:      "",
            userEmail:     "test@example.com",
            repoError:     nil,
            wantErr:       true,
            wantInfoLogs:  1,
            wantErrorLogs: 1,
        },
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            // Setup mocks
            mockRepo := &mockRepository{
                saveFunc: func(u *User) error {
                    // Valida parâmetros
                    if u.Name != tt.userName {
                        t.Errorf("Save chamado com Name = %s; want %s",
                            u.Name, tt.userName)
                    }
                    return tt.repoError
                },
            }
            
            mockLog := &mockLogger{}
            
            // Cria service com mocks injetados
            service := NewUserService(mockRepo, mockLog)
            
            // Execute
            user, err := service.CreateUser(tt.userName, tt.userEmail)
            
            // Validate
            if (err != nil) != tt.wantErr {
                t.Errorf("CreateUser() erro = %v; wantErr %v", err, tt.wantErr)
            }
            
            if !tt.wantErr && user == nil {
                t.Error("user deveria ter sido criado")
            }
            
            // Valida logs
            if len(mockLog.infoMessages) != tt.wantInfoLogs {
                t.Errorf("Info logs = %d; want %d", 
                    len(mockLog.infoMessages), tt.wantInfoLogs)
            }
            
            if len(mockLog.errorMessages) != tt.wantErrorLogs {
                t.Errorf("Error logs = %d; want %d",
                    len(mockLog.errorMessages), tt.wantErrorLogs)
            }
        })
    }
}

// Testando struct com estado complexo
type Cache struct {
    data   map[string]interface{}
    hits   int
    misses int
}

func NewCache() *Cache {
    return &Cache{
        data: make(map[string]interface{}),
    }
}

func (c *Cache) Get(key string) (interface{}, bool) {
    val, ok := c.data[key]
    if ok {
        c.hits++
    } else {
        c.misses++
    }
    return val, ok
}

func (c *Cache) Set(key string, value interface{}) {
    c.data[key] = value
}

func (c *Cache) Stats() (hits, misses int) {
    return c.hits, c.misses
}

func TestCache(t *testing.T) {
    t.Run("Get e Set", func(t *testing.T) {
        cache := NewCache()
        
        // Set
        cache.Set("key1", "value1")
        
        // Get existente
        val, ok := cache.Get("key1")
        if !ok {
            t.Fatal("key1 deveria existir")
        }
        if val != "value1" {
            t.Errorf("val = %v; want value1", val)
        }
        
        // Get não existente
        _, ok = cache.Get("key2")
        if ok {
            t.Error("key2 não deveria existir")
        }
    })
    
    t.Run("Stats", func(t *testing.T) {
        cache := NewCache()
        
        cache.Set("key1", "value1")
        cache.Get("key1")  // hit
        cache.Get("key2")  // miss
        cache.Get("key1")  // hit
        cache.Get("key3")  // miss
        
        hits, misses := cache.Stats()
        
        if hits != 2 {
            t.Errorf("hits = %d; want 2", hits)
        }
        
        if misses != 2 {
            t.Errorf("misses = %d; want 2", misses)
        }
    })
    
    t.Run("múltiplas operações", func(t *testing.T) {
        cache := NewCache()
        
        // Set múltiplos valores
        for i := 0; i < 10; i++ {
            cache.Set(fmt.Sprintf("key%d", i), i)
        }
        
        // Get todos
        for i := 0; i < 10; i++ {
            val, ok := cache.Get(fmt.Sprintf("key%d", i))
            if !ok {
                t.Errorf("key%d não encontrado", i)
            }
            if val != i {
                t.Errorf("key%d: got %v; want %d", i, val, i)
            }
        }
        
        // Valida stats
        hits, misses := cache.Stats()
        if hits != 10 {
            t.Errorf("hits = %d; want 10", hits)
        }
        if misses != 0 {
            t.Errorf("misses = %d; want 0", misses)
        }
    })
}

// Constructor functions e testes
func NewUser(name, email string, age int) (*User, error) {
    if name == "" {
        return nil, errors.New("nome vazio")
    }
    if email == "" {
        return nil, errors.New("email vazio")
    }
    if age < 0 {
        return nil, errors.New("idade negativa")
    }
    
    return &User{
        Name:      name,
        Email:     email,
        Age:       age,
        CreatedAt: time.Now(),
    }, nil
}

func TestNewUser(t *testing.T) {
    tests := []struct {
        name      string
        userName  string
        email     string
        age       int
        wantErr   bool
    }{
        {
            name:     "válido",
            userName: "John",
            email:    "john@example.com",
            age:      25,
            wantErr:  false,
        },
        {
            name:     "nome vazio",
            userName: "",
            email:    "test@example.com",
            age:      25,
            wantErr:  true,
        },
        {
            name:     "email vazio",
            userName: "John",
            email:    "",
            age:      25,
            wantErr:  true,
        },
        {
            name:     "idade negativa",
            userName: "John",
            email:    "john@example.com",
            age:      -1,
            wantErr:  true,
        },
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            user, err := NewUser(tt.userName, tt.email, tt.age)
            
            if (err != nil) != tt.wantErr {
                t.Errorf("NewUser() erro = %v; wantErr %v", err, tt.wantErr)
                return
            }
            
            if !tt.wantErr {
                if user == nil {
                    t.Fatal("user não deveria ser nil")
                }
                
                if user.Name != tt.userName {
                    t.Errorf("Name = %s; want %s", user.Name, tt.userName)
                }
                
                if user.Email != tt.email {
                    t.Errorf("Email = %s; want %s", user.Email, tt.email)
                }
                
                if user.Age != tt.age {
                    t.Errorf("Age = %d; want %d", user.Age, tt.age)
                }
                
                if user.CreatedAt.IsZero() {
                    t.Error("CreatedAt não deveria ser zero")
                }
            }
        })
    }
}

// Testando struct com métodos encadeados (method chaining)
type QueryBuilder struct {
    table   string
    fields  []string
    where   string
    orderBy string
}

func NewQueryBuilder() *QueryBuilder {
    return &QueryBuilder{}
}

func (q *QueryBuilder) From(table string) *QueryBuilder {
    q.table = table
    return q
}

func (q *QueryBuilder) Select(fields ...string) *QueryBuilder {
    q.fields = fields
    return q
}

func (q *QueryBuilder) Where(condition string) *QueryBuilder {
    q.where = condition
    return q
}

func (q *QueryBuilder) OrderBy(field string) *QueryBuilder {
    q.orderBy = field
    return q
}

func (q *QueryBuilder) Build() string {
    query := "SELECT "
    if len(q.fields) == 0 {
        query += "*"
    } else {
        query += strings.Join(q.fields, ", ")
    }
    query += " FROM " + q.table
    
    if q.where != "" {
        query += " WHERE " + q.where
    }
    
    if q.orderBy != "" {
        query += " ORDER BY " + q.orderBy
    }
    
    return query
}

func TestQueryBuilder(t *testing.T) {
    tests := []struct {
        name  string
        build func() string
        want  string
    }{
        {
            name: "query simples",
            build: func() string {
                return NewQueryBuilder().
                    From("users").
                    Build()
            },
            want: "SELECT * FROM users",
        },
        {
            name: "com campos específicos",
            build: func() string {
                return NewQueryBuilder().
                    From("users").
                    Select("id", "name", "email").
                    Build()
            },
            want: "SELECT id, name, email FROM users",
        },
        {
            name: "com WHERE",
            build: func() string {
                return NewQueryBuilder().
                    From("users").
                    Where("age > 18").
                    Build()
            },
            want: "SELECT * FROM users WHERE age > 18",
        },
        {
            name: "query completa",
            build: func() string {
                return NewQueryBuilder().
                    From("users").
                    Select("name", "email").
                    Where("active = true").
                    OrderBy("name").
                    Build()
            },
            want: "SELECT name, email FROM users WHERE active = true ORDER BY name",
        },
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            got := tt.build()
            
            if got != tt.want {
                t.Errorf("Build() = %q; want %q", got, tt.want)
            }
        })
    }
}

// Testando struct com estado que persiste entre chamadas
type Counter struct {
    value int
}

func (c *Counter) Increment() {
    c.value++
}

func (c *Counter) Decrement() {
    c.value--
}

func (c *Counter) Value() int {
    return c.value
}

func (c *Counter) Reset() {
    c.value = 0
}

func TestCounter(t *testing.T) {
    t.Run("incremento", func(t *testing.T) {
        c := &Counter{}
        
        c.Increment()
        if c.Value() != 1 {
            t.Errorf("após Increment: %d; want 1", c.Value())
        }
        
        c.Increment()
        if c.Value() != 2 {
            t.Errorf("após 2x Increment: %d; want 2", c.Value())
        }
    })
    
    t.Run("decremento", func(t *testing.T) {
        c := &Counter{value: 5}
        
        c.Decrement()
        if c.Value() != 4 {
            t.Errorf("após Decrement: %d; want 4", c.Value())
        }
    })
    
    t.Run("reset", func(t *testing.T) {
        c := &Counter{value: 10}
        
        c.Reset()
        if c.Value() != 0 {
            t.Errorf("após Reset: %d; want 0", c.Value())
        }
    })
    
    t.Run("múltiplas operações", func(t *testing.T) {
        c := &Counter{}
        
        c.Increment()
        c.Increment()
        c.Increment()
        c.Decrement()
        
        if c.Value() != 2 {
            t.Errorf("Value = %d; want 2", c.Value())
        }
        
        c.Reset()
        if c.Value() != 0 {
            t.Errorf("após Reset: %d; want 0", c.Value())
        }
    })
}
```

## Padrões Importantes

### Value vs Pointer Receivers
```go
// Value receiver - NÃO modifica o original
type Point struct {
    X, Y int
}

func (p Point) Move(dx, dy int) {
    p.X += dx
    p.Y += dy
    // Modifica CÓPIA, não o original
}

func TestPoint_ValueReceiver(t *testing.T) {
    p := Point{X: 0, Y: 0}
    p.Move(5, 10)
    
    // Original NÃO mudou
    if p.X != 0 || p.Y != 0 {
        t.Error("value receiver não deveria modificar original")
    }
}

// Pointer receiver - modifica o original
func (p *Point) MovePtr(dx, dy int) {
    p.X += dx
    p.Y += dy
    // Modifica o original
}

func TestPoint_PointerReceiver(t *testing.T) {
    p := &Point{X: 0, Y: 0}
    p.MovePtr(5, 10)
    
    // Original mudou
    if p.X != 5 || p.Y != 10 {
        t.Errorf("got (%d, %d); want (5, 10)", p.X, p.Y)
    }
}
```

### Testando Interfaces
```go
// Interface
type Writer interface {
    Write(data []byte) error
}

// Implementação
type FileWriter struct {
    path string
}

func (f *FileWriter) Write(data []byte) error {
    return os.WriteFile(f.path, data, 0644)
}

// Testa que struct implementa interface
func TestFileWriter_ImplementsWriter(t *testing.T) {
    var _ Writer = (*FileWriter)(nil)  // compile-time check
}

// Testa comportamento
func TestFileWriter_Write(t *testing.T) {
    tmpFile := createTempFile(t)
    
    writer := &FileWriter{path: tmpFile}
    data := []byte("test data")
    
    err := writer.Write(data)
    if err != nil {
        t.Fatalf("Write falhou: %v", err)
    }
    
    // Verifica que arquivo foi escrito
    content, _ := os.ReadFile(tmpFile)
    if string(content) != "test data" {
        t.Errorf("content = %q; want 'test data'", content)
    }
}
```

## Boas Práticas
```
✅ Crie instâncias frescas para cada teste
✅ Use injeção de dependências
✅ Teste métodos individuais E workflows
✅ Valide modificações de estado
✅ Use mocks para dependências externas
✅ Teste constructors/factories
✅ Valide que interfaces são implementadas
✅ Teste method chaining se aplicável

❌ Não compartilhe instâncias entre testes
❌ Não teste implementação interna
❌ Não ignore side effects
❌ Não esqueça de testar edge cases
❌ Não use variáveis globais
```