# Table-Driven Tests (Padrão Go)

Table-driven tests são o padrão idiomático em Go para testar múltiplos casos de uma função. Ao invés de escrever funções de teste separadas para cada cenário, você define uma "tabela" (slice de structs) com inputs e outputs esperados, então itera sobre ela. Esse padrão reduz drasticamente duplicação de código, torna fácil adicionar novos casos, e facilita a leitura dos testes.

A grande vantagem dos table-driven tests é a separação clara entre **dados** (os casos de teste) e **lógica** (como executar e validar). Quando você precisa adicionar um novo caso, apenas adiciona uma entrada na tabela - a lógica de execução permanece inalterada. Isso também torna trivial testar edge cases: basta adicionar mais uma linha na tabela. É o padrão mais usado em projetos Go de código aberto e na própria biblioteca padrão.
```go
package calc

import "testing"

// Table-driven test básico
func TestAdd(t *testing.T) {
    // Define a tabela de casos de teste
    tests := []struct {
        name     string  // nome descritivo do caso
        a        int     // inputs
        b        int
        expected int     // output esperado
    }{
        {name: "positivos", a: 2, b: 3, expected: 5},
        {name: "com zero", a: 0, b: 5, expected: 5},
        {name: "negativos", a: -2, b: -3, expected: -5},
        {name: "positivo e negativo", a: 10, b: -5, expected: 5},
    }
    
    // Itera sobre os casos
    for _, tt := range tests {
        result := Add(tt.a, tt.b)
        
        if result != tt.expected {
            t.Errorf("Add(%d, %d) = %d; want %d", 
                tt.a, tt.b, result, tt.expected)
        }
    }
}

// Table-driven test com validação de erro
func TestDivide(t *testing.T) {
    tests := []struct {
        name    string
        a       int
        b       int
        want    int
        wantErr bool  // indica se espera erro
    }{
        {
            name:    "divisão normal",
            a:       10,
            b:       2,
            want:    5,
            wantErr: false,
        },
        {
            name:    "divisão por zero",
            a:       10,
            b:       0,
            want:    0,
            wantErr: true,
        },
        {
            name:    "resultado negativo",
            a:       -10,
            b:       2,
            want:    -5,
            wantErr: false,
        },
        {
            name:    "divisão exata",
            a:       100,
            b:       10,
            want:    10,
            wantErr: false,
        },
    }
    
    for _, tt := range tests {
        result, err := Divide(tt.a, tt.b)
        
        // Valida erro
        if (err != nil) != tt.wantErr {
            t.Errorf("Divide(%d, %d) error = %v; wantErr %v", 
                tt.a, tt.b, err, tt.wantErr)
            continue
        }
        
        // Só valida resultado se não esperava erro
        if !tt.wantErr && result != tt.want {
            t.Errorf("Divide(%d, %d) = %d; want %d", 
                tt.a, tt.b, result, tt.want)
        }
    }
}

// Table-driven test com mensagem de erro esperada
func TestValidateAge(t *testing.T) {
    tests := []struct {
        name     string
        age      int
        wantErr  bool
        errorMsg string  // mensagem de erro esperada
    }{
        {
            name:     "idade válida",
            age:      25,
            wantErr:  false,
            errorMsg: "",
        },
        {
            name:     "menor de idade",
            age:      15,
            wantErr:  true,
            errorMsg: "menor de idade",
        },
        {
            name:     "idade negativa",
            age:      -5,
            wantErr:  true,
            errorMsg: "idade negativa",
        },
        {
            name:     "idade muito alta",
            age:      150,
            wantErr:  true,
            errorMsg: "idade inválida",
        },
    }
    
    for _, tt := range tests {
        err := ValidateAge(tt.age)
        
        if (err != nil) != tt.wantErr {
            t.Errorf("%s: ValidateAge(%d) erro = %v; wantErr %v",
                tt.name, tt.age, err, tt.wantErr)
            continue
        }
        
        if tt.wantErr && err != nil {
            if !strings.Contains(err.Error(), tt.errorMsg) {
                t.Errorf("%s: erro = %q; deveria conter %q",
                    tt.name, err.Error(), tt.errorMsg)
            }
        }
    }
}

// Table-driven test com múltiplos outputs
func TestParseUser(t *testing.T) {
    tests := []struct {
        name      string
        input     string
        wantName  string
        wantEmail string
        wantAge   int
        wantErr   bool
    }{
        {
            name:      "JSON válido",
            input:     `{"name":"John","email":"john@example.com","age":30}`,
            wantName:  "John",
            wantEmail: "john@example.com",
            wantAge:   30,
            wantErr:   false,
        },
        {
            name:      "JSON inválido",
            input:     `{invalid json}`,
            wantName:  "",
            wantEmail: "",
            wantAge:   0,
            wantErr:   true,
        },
        {
            name:      "campos faltando",
            input:     `{"name":"Jane"}`,
            wantName:  "Jane",
            wantEmail: "",
            wantAge:   0,
            wantErr:   false,
        },
    }
    
    for _, tt := range tests {
        user, err := ParseUser(tt.input)
        
        if (err != nil) != tt.wantErr {
            t.Errorf("%s: erro = %v; wantErr %v", tt.name, err, tt.wantErr)
            continue
        }
        
        if !tt.wantErr {
            if user.Name != tt.wantName {
                t.Errorf("%s: Name = %q; want %q", tt.name, user.Name, tt.wantName)
            }
            if user.Email != tt.wantEmail {
                t.Errorf("%s: Email = %q; want %q", tt.name, user.Email, tt.wantEmail)
            }
            if user.Age != tt.wantAge {
                t.Errorf("%s: Age = %d; want %d", tt.name, user.Age, tt.wantAge)
            }
        }
    }
}

// Table-driven test com slices
func TestSum(t *testing.T) {
    tests := []struct {
        name     string
        numbers  []int
        expected int
    }{
        {
            name:     "slice vazio",
            numbers:  []int{},
            expected: 0,
        },
        {
            name:     "um elemento",
            numbers:  []int{5},
            expected: 5,
        },
        {
            name:     "múltiplos positivos",
            numbers:  []int{1, 2, 3, 4, 5},
            expected: 15,
        },
        {
            name:     "com negativos",
            numbers:  []int{10, -5, 3},
            expected: 8,
        },
        {
            name:     "todos zeros",
            numbers:  []int{0, 0, 0},
            expected: 0,
        },
    }
    
    for _, tt := range tests {
        result := Sum(tt.numbers)
        
        if result != tt.expected {
            t.Errorf("%s: Sum(%v) = %d; want %d",
                tt.name, tt.numbers, result, tt.expected)
        }
    }
}

// Sintaxe alternativa: struct inline (mais compacto)
func TestMax(t *testing.T) {
    tests := []struct {
        a, b, want int
    }{
        {1, 2, 2},
        {2, 1, 2},
        {5, 5, 5},
        {-1, -2, -1},
        {0, 0, 0},
    }
    
    for _, tt := range tests {
        got := Max(tt.a, tt.b)
        if got != tt.want {
            t.Errorf("Max(%d, %d) = %d; want %d", tt.a, tt.b, got, tt.want)
        }
    }
}

// Table-driven test com strings
func TestIsValidEmail(t *testing.T) {
    tests := []struct {
        name  string
        email string
        valid bool
    }{
        {"válido simples", "user@example.com", true},
        {"válido com números", "user123@example.com", true},
        {"válido com pontos", "user.name@example.com", true},
        {"sem @", "userexample.com", false},
        {"sem domínio", "user@", false},
        {"vazio", "", false},
        {"espaços", "user @example.com", false},
        {"múltiplos @", "user@@example.com", false},
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            result := IsValidEmail(tt.email)
            
            if result != tt.valid {
                t.Errorf("IsValidEmail(%q) = %v; want %v",
                    tt.email, result, tt.valid)
            }
        })
    }
}

// Table-driven test com structs complexas
func TestUserValidation(t *testing.T) {
    tests := []struct {
        name    string
        user    User
        wantErr bool
        errMsg  string
    }{
        {
            name: "usuário válido",
            user: User{
                Name:  "John Doe",
                Email: "john@example.com",
                Age:   25,
            },
            wantErr: false,
        },
        {
            name: "nome vazio",
            user: User{
                Name:  "",
                Email: "john@example.com",
                Age:   25,
            },
            wantErr: true,
            errMsg:  "nome vazio",
        },
        {
            name: "email inválido",
            user: User{
                Name:  "John Doe",
                Email: "invalid-email",
                Age:   25,
            },
            wantErr: true,
            errMsg:  "email inválido",
        },
        {
            name: "idade negativa",
            user: User{
                Name:  "John Doe",
                Email: "john@example.com",
                Age:   -5,
            },
            wantErr: true,
            errMsg:  "idade inválida",
        },
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            err := tt.user.Validate()
            
            if (err != nil) != tt.wantErr {
                t.Errorf("Validate() erro = %v; wantErr %v", err, tt.wantErr)
                return
            }
            
            if tt.wantErr && !strings.Contains(err.Error(), tt.errMsg) {
                t.Errorf("erro = %q; deveria conter %q", err.Error(), tt.errMsg)
            }
        })
    }
}

// Padrão avançado: subtabelas (nested tables)
func TestStringOperations(t *testing.T) {
    t.Run("ToUpper", func(t *testing.T) {
        tests := []struct {
            input string
            want  string
        }{
            {"hello", "HELLO"},
            {"Hello", "HELLO"},
            {"HELLO", "HELLO"},
            {"", ""},
        }
        
        for _, tt := range tests {
            got := strings.ToUpper(tt.input)
            if got != tt.want {
                t.Errorf("ToUpper(%q) = %q; want %q", tt.input, got, tt.want)
            }
        }
    })
    
    t.Run("ToLower", func(t *testing.T) {
        tests := []struct {
            input string
            want  string
        }{
            {"HELLO", "hello"},
            {"Hello", "hello"},
            {"hello", "hello"},
            {"", ""},
        }
        
        for _, tt := range tests {
            got := strings.ToLower(tt.input)
            if got != tt.want {
                t.Errorf("ToLower(%q) = %q; want %q", tt.input, got, tt.want)
            }
        }
    })
}
```

## Quando Usar Table-Driven Tests

### ✅ Use quando:

- Testando mesma função com inputs diferentes
- Testando edge cases (zeros, negativos, limites, strings vazias)
- Validando comportamento consistente
- Há 3+ cenários similares
- Quer facilitar adição de novos casos
- Quer reduzir duplicação de código

### ❌ Não use quando:

- Teste único e simples (overhead desnecessário)
- Cada caso precisa de setup/teardown muito diferente
- Lógica de validação muito diferente entre casos
- Apenas 1-2 casos de teste

## Padrões de Nomenclatura
```go
// Campos comuns na struct de teste
tests := []struct {
    name     string  // SEMPRE inclua - documenta o cenário
    
    // Inputs
    input    string
    age      int
    data     []byte
    
    // Outputs esperados
    want     int
    wantErr  bool
    errorMsg string
    
    // Flags de comportamento
    skip     bool  // pular este caso?
}
```

## Dicas Práticas
```go
// 1. Use nomes descritivos
{name: "empty string", ...}           // ✅ Bom
{name: "test1", ...}                  // ❌ Ruim

// 2. Agrupe casos relacionados
{name: "positive number", ...}
{name: "negative number", ...}
{name: "zero", ...}

// 3. Use continue para não validar após erro
if (err != nil) != tt.wantErr {
    t.Errorf(...)
    continue  // não valida resultado se erro inesperado
}

// 4. Seja explícito com valores esperados
wantErr: false,  // ✅ explícito
// wantErr omitido // ❌ depende de zero value

// 5. Use comentários para casos complexos
{
    name: "edge case especial",
    // Este caso testa comportamento quando X acontece...
    input: "special",
    want: 42,
},
```

## Comparação: Antes e Depois

### ❌ Antes (sem table-driven):
```go
func TestAddPositive(t *testing.T) {
    if Add(2, 3) != 5 {
        t.Error("failed")
    }
}

func TestAddNegative(t *testing.T) {
    if Add(-2, -3) != -5 {
        t.Error("failed")
    }
}

func TestAddZero(t *testing.T) {
    if Add(0, 0) != 0 {
        t.Error("failed")
    }
}
// Muito código repetido!
```

### ✅ Depois (com table-driven):
```go
func TestAdd(t *testing.T) {
    tests := []struct {
        name     string
        a, b     int
        expected int
    }{
        {"positive", 2, 3, 5},
        {"negative", -2, -3, -5},
        {"zero", 0, 0, 0},
    }
    
    for _, tt := range tests {
        if got := Add(tt.a, tt.b); got != tt.expected {
            t.Errorf("%s: Add(%d, %d) = %d; want %d",
                tt.name, tt.a, tt.b, got, tt.expected)
        }
    }
}
// Muito mais limpo e fácil de adicionar casos!
```