# Subtests com t.Run()

Subtests permitem organizar testes relacionados em grupos hierárquicos, fornecendo isolamento entre casos e permitindo execução seletiva. Cada subtest roda em sua própria goroutine, tem seu próprio nome completo (`TestPai/SubtestFilho`), e falhas são reportadas individualmente. Isso é especialmente poderoso quando combinado com table-driven tests.

A principal vantagem dos subtests é o **isolamento**: se um caso falha, os outros continuam executando. Isso dá visibilidade completa de quais casos passam e quais falham, ao invés de parar no primeiro erro. Além disso, você pode rodar subtests específicos com `-run TestName/SubtestName`, perfeito durante debugging. Subtests também permitem setup e teardown por caso, uso de `t.Parallel()` para paralelização, e uma organização hierárquica clara dos testes.
```go
package calc

import (
    "strings"
    "testing"
)

// Combinando table-driven tests com subtests (PADRÃO MAIS COMUM)
func TestAdd(t *testing.T) {
    tests := []struct {
        name     string
        a        int
        b        int
        expected int
    }{
        {"positivos", 2, 3, 5},
        {"com zero", 0, 5, 5},
        {"negativos", -2, -3, -5},
        {"resultado zero", 5, -5, 0},
    }
    
    for _, tt := range tests {
        // t.Run cria um subtest
        t.Run(tt.name, func(t *testing.T) {
            result := Add(tt.a, tt.b)
            
            if result != tt.expected {
                t.Errorf("Add(%d, %d) = %d; want %d", 
                    tt.a, tt.b, result, tt.expected)
            }
        })
    }
}

// Output do teste acima:
// === RUN   TestAdd
// === RUN   TestAdd/positivos
// === RUN   TestAdd/com_zero
// === RUN   TestAdd/negativos
// === RUN   TestAdd/resultado_zero
// --- PASS: TestAdd (0.00s)
//     --- PASS: TestAdd/positivos (0.00s)
//     --- PASS: TestAdd/com_zero (0.00s)
//     --- PASS: TestAdd/negativos (0.00s)
//     --- PASS: TestAdd/resultado_zero (0.00s)

// Subtests sem table (agrupamento lógico)
func TestCalculator(t *testing.T) {
    t.Run("Addition", func(t *testing.T) {
        if Add(2, 3) != 5 {
            t.Error("Add falhou")
        }
    })
    
    t.Run("Subtraction", func(t *testing.T) {
        if Subtract(5, 3) != 2 {
            t.Error("Subtract falhou")
        }
    })
    
    t.Run("Division", func(t *testing.T) {
        t.Run("Success", func(t *testing.T) {
            result, err := Divide(10, 2)
            if err != nil {
                t.Fatal("erro inesperado")
            }
            if result != 5 {
                t.Error("resultado incorreto")
            }
        })
        
        t.Run("ByZero", func(t *testing.T) {
            _, err := Divide(10, 0)
            if err == nil {
                t.Error("deveria retornar erro")
            }
        })
    })
}

// Subtests hierárquicos (nested)
func TestUserOperations(t *testing.T) {
    t.Run("Create", func(t *testing.T) {
        t.Run("ValidData", func(t *testing.T) {
            user, err := CreateUser("John", "john@example.com")
            if err != nil {
                t.Fatalf("erro inesperado: %v", err)
            }
            if user.Name != "John" {
                t.Error("nome incorreto")
            }
        })
        
        t.Run("EmptyName", func(t *testing.T) {
            _, err := CreateUser("", "john@example.com")
            if err == nil {
                t.Error("deveria retornar erro")
            }
        })
        
        t.Run("InvalidEmail", func(t *testing.T) {
            _, err := CreateUser("John", "invalid-email")
            if err == nil {
                t.Error("deveria retornar erro")
            }
        })
    })
    
    t.Run("Update", func(t *testing.T) {
        t.Run("Success", func(t *testing.T) {
            // testa update com sucesso
        })
        
        t.Run("NotFound", func(t *testing.T) {
            // testa update de usuário inexistente
        })
    })
}

// Subtests com setup compartilhado
func TestStringProcessor(t *testing.T) {
    // Setup comum para todos os subtests
    input := "Hello World"
    
    t.Run("ToUpper", func(t *testing.T) {
        result := strings.ToUpper(input)
        if result != "HELLO WORLD" {
            t.Errorf("ToUpper falhou: %s", result)
        }
    })
    
    t.Run("ToLower", func(t *testing.T) {
        result := strings.ToLower(input)
        if result != "hello world" {
            t.Errorf("ToLower falhou: %s", result)
        }
    })
    
    t.Run("Length", func(t *testing.T) {
        if len(input) != 11 {
            t.Errorf("Length = %d; want 11", len(input))
        }
    })
}

// Setup e teardown por subtest
func TestDatabaseOperations(t *testing.T) {
    tests := []struct {
        name string
        op   func(*DB) error
    }{
        {
            name: "insert",
            op: func(db *DB) error {
                return db.Insert("key", "value")
            },
        },
        {
            name: "delete",
            op: func(db *DB) error {
                return db.Delete("key")
            },
        },
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            // Setup específico para este subtest
            db := NewTestDB(t)
            defer db.Close()  // teardown
            
            // Execute operação
            err := tt.op(db)
            
            if err != nil {
                t.Errorf("operação %s falhou: %v", tt.name, err)
            }
        })
    }
}

// Subtests com t.Parallel() - execução paralela
func TestParallelOperations(t *testing.T) {
    tests := []struct {
        name  string
        input int
        want  int
    }{
        {"caso1", 1, 2},
        {"caso2", 2, 4},
        {"caso3", 3, 6},
    }
    
    for _, tt := range tests {
        tt := tt  // captura variável do loop (necessário em Go < 1.22)
        
        t.Run(tt.name, func(t *testing.T) {
            t.Parallel()  // marca como paralelo
            
            // Este teste roda em paralelo com outros
            result := Process(tt.input)
            
            if result != tt.want {
                t.Errorf("Process(%d) = %d; want %d", 
                    tt.input, result, tt.want)
            }
        })
    }
}

// IMPORTANTE: captura de variável do loop
func TestLoopVariableCapture(t *testing.T) {
    tests := []struct {
        name string
        val  int
    }{
        {"test1", 1},
        {"test2", 2},
    }
    
    // ❌ ERRADO (Go < 1.22)
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            t.Parallel()
            // tt pode ter mudado quando este subtest executar!
            _ = tt.val
        })
    }
    
    // ✅ CORRETO (Go < 1.22)
    for _, tt := range tests {
        tt := tt  // captura a variável
        t.Run(tt.name, func(t *testing.T) {
            t.Parallel()
            // agora tt é seguro de usar
            _ = tt.val
        })
    }
    
    // ✅ CORRETO (Go >= 1.22)
    // A partir de Go 1.22, não precisa mais capturar
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            t.Parallel()
            _ = tt.val  // seguro sem captura explícita
        })
    }
}

// Subtests com validação condicional
func TestConditionalValidation(t *testing.T) {
    tests := []struct {
        name       string
        input      string
        wantErr    bool
        wantResult string
    }{
        {"sucesso", "valid", false, "VALID"},
        {"erro", "invalid", true, ""},
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            result, err := Process(tt.input)
            
            // Valida erro
            if (err != nil) != tt.wantErr {
                t.Errorf("erro = %v; wantErr %v", err, tt.wantErr)
                return  // para se validação de erro falhou
            }
            
            // Só valida resultado se não esperava erro
            if !tt.wantErr && result != tt.wantResult {
                t.Errorf("result = %q; want %q", result, tt.wantResult)
            }
        })
    }
}

// Subtests com cleanup
func TestWithCleanup(t *testing.T) {
    tests := []string{"test1", "test2", "test3"}
    
    for _, name := range tests {
        name := name
        
        t.Run(name, func(t *testing.T) {
            // Setup
            file := createTempFile(t)
            
            // Cleanup automático ao final deste subtest
            t.Cleanup(func() {
                os.Remove(file.Name())
            })
            
            // Teste usa o arquivo
            // ...
        })
    }
}

// Subtests que podem ser pulados
func TestSkippableSubtests(t *testing.T) {
    tests := []struct {
        name string
        skip bool
        test func(*testing.T)
    }{
        {
            name: "rápido",
            skip: false,
            test: func(t *testing.T) {
                // teste rápido
            },
        },
        {
            name: "lento",
            skip: testing.Short(),  // pula em modo -short
            test: func(t *testing.T) {
                // teste demorado
            },
        },
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            if tt.skip {
                t.Skip("pulando teste")
            }
            
            tt.test(t)
        })
    }
}

// Organizando testes por categoria
func TestUserAPI(t *testing.T) {
    t.Run("GET", func(t *testing.T) {
        t.Run("Success", func(t *testing.T) {
            // testa GET com sucesso
        })
        
        t.Run("NotFound", func(t *testing.T) {
            // testa GET 404
        })
    })
    
    t.Run("POST", func(t *testing.T) {
        t.Run("ValidData", func(t *testing.T) {
            // testa POST com dados válidos
        })
        
        t.Run("InvalidData", func(t *testing.T) {
            // testa POST com dados inválidos
        })
    })
    
    t.Run("DELETE", func(t *testing.T) {
        t.Run("Existing", func(t *testing.T) {
            // testa DELETE de recurso existente
        })
        
        t.Run("NotFound", func(t *testing.T) {
            // testa DELETE de recurso inexistente
        })
    })
}
```

## Executando Subtests Específicos
```bash
# Roda todos os subtests de TestAdd
go test -v -run TestAdd

# Roda apenas o subtest "positivos"
go test -v -run TestAdd/positivos

# Roda subtests que correspondem ao padrão
go test -v -run TestAdd/.*zero

# Roda subtests hierárquicos
go test -v -run TestUserOperations/Create/ValidData

# Roda múltiplos subtests com regex
go test -v -run "TestAdd/(positivos|negativos)"

# Modo verboso mostra hierarquia completa
go test -v -run TestCalculator
# Output:
# === RUN   TestCalculator
# === RUN   TestCalculator/Addition
# === RUN   TestCalculator/Division
# === RUN   TestCalculator/Division/Success
# === RUN   TestCalculator/Division/ByZero
```

## Vantagens dos Subtests

### ✅ Isolamento
- Um subtest falhando não para os outros
- Visibilidade completa: vê todos os erros de uma vez
- Cada subtest é independente

### ✅ Execução Seletiva
- Rode apenas o subtest que está debugando
- Economiza tempo durante desenvolvimento
- Útil para testes lentos

### ✅ Organização
- Agrupa testes relacionados logicamente
- Hierarquia clara e legível
- Facilita navegação em projetos grandes

### ✅ Setup/Teardown Granular
- Setup comum para grupo de subtests
- Cleanup específico por subtest
- `t.Cleanup()` automático

### ✅ Paralelização
- `t.Parallel()` dentro de subtests
- Acelera execução de suíte de testes
- Isolamento garantido

## Padrões e Anti-padrões

### ✅ Boas Práticas
```go
// Nomes descritivos
t.Run("empty string returns error", func(t *testing.T) { ... })

// Combina com table-driven
for _, tt := range tests {
    t.Run(tt.name, func(t *testing.T) { ... })
}

// Hierarquia lógica
t.Run("Create", func(t *testing.T) {
    t.Run("Success", func(t *testing.T) { ... })
    t.Run("Error", func(t *testing.T) { ... })
})

// Captura variável do loop (Go < 1.22)
for _, tt := range tests {
    tt := tt
    t.Run(tt.name, func(t *testing.T) { ... })
}
```

### ❌ Anti-padrões
```go
// Nomes genéricos
t.Run("test1", func(t *testing.T) { ... })  // ❌

// Subtests dependentes
t.Run("first", func(t *testing.T) {
    globalVar = 10  // ❌ estado compartilhado
})
t.Run("second", func(t *testing.T) {
    // depende de globalVar ❌
})

// Hierarquia muito profunda
t.Run("A", func(t *testing.T) {
    t.Run("B", func(t *testing.T) {
        t.Run("C", func(t *testing.T) {
            t.Run("D", func(t *testing.T) {  // ❌ muito profundo
                ...
            })
        })
    })
})

// Esquecer captura de variável
for _, tt := range tests {
    t.Run(tt.name, func(t *testing.T) {
        t.Parallel()
        _ = tt.val  // ❌ race condition (Go < 1.22)
    })
}
```

## Quando Usar Subtests

### ✅ Use quando:
- Combinar com table-driven tests (quase sempre)
- Agrupar testes relacionados logicamente
- Precisa executar testes específicos durante debug
- Quer setup/teardown por grupo
- Quer paralelizar testes independentes
- Tem hierarquia natural de testes

### ❌ Evite quando:
- Teste único e simples (overhead desnecessário)
- Subtests teriam dependências entre si
- Hierarquia ficaria muito profunda (>3 níveis)
- Nome do subtest não adiciona valor